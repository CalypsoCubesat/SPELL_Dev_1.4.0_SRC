/*
 * generated by Xtext
 */
package lu.ses.engineering.spell.serializer;

import com.google.inject.Inject;
import java.util.List;
import lu.ses.engineering.spell.services.SpellDatabaseGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.TokenAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynNavigable;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;

@SuppressWarnings("all")
public class SpellDatabaseSyntacticSequencer extends AbstractSyntacticSequencer {

	protected SpellDatabaseGrammarAccess grammarAccess;
	protected AbstractElementAlias match_CSVCommand_CommaKeyword_3_2_0_4_a;
	protected AbstractElementAlias match_CSVCommand_CommaKeyword_4_a;
	protected AbstractElementAlias match_CSVSpell_CommaKeyword_3_a;
	protected AbstractElementAlias match_CSVTelemetry_CommaKeyword_4_a;
	protected AbstractElementAlias match_DatabaseEntry_WSTerminalRuleCall_1_q;
	protected AbstractElementAlias match_DatabaseEntry_WSTerminalRuleCall_3_q;
	protected AbstractElementAlias match_Dictionary_CommaKeyword_4_q;
	protected AbstractElementAlias match_List_CommaKeyword_4_q;
	protected AbstractElementAlias match_SpellCommand_CommaKeyword_1_2_a;
	protected AbstractElementAlias match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_a;
	protected AbstractElementAlias match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_p;
	protected AbstractElementAlias match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_2_q;
	protected AbstractElementAlias match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_3_0_q;
	protected AbstractElementAlias match_TCArgs_CommaKeyword_5_0_0_q;
	protected AbstractElementAlias match_TCArgs_CommaKeyword_6_a;
	protected AbstractElementAlias match_Tuple_CommaKeyword_4_q;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (SpellDatabaseGrammarAccess) access;
		match_CSVCommand_CommaKeyword_3_2_0_4_a = new TokenAlias(true, true, grammarAccess.getCSVCommandAccess().getCommaKeyword_3_2_0_4());
		match_CSVCommand_CommaKeyword_4_a = new TokenAlias(true, true, grammarAccess.getCSVCommandAccess().getCommaKeyword_4());
		match_CSVSpell_CommaKeyword_3_a = new TokenAlias(true, true, grammarAccess.getCSVSpellAccess().getCommaKeyword_3());
		match_CSVTelemetry_CommaKeyword_4_a = new TokenAlias(true, true, grammarAccess.getCSVTelemetryAccess().getCommaKeyword_4());
		match_DatabaseEntry_WSTerminalRuleCall_1_q = new TokenAlias(false, true, grammarAccess.getDatabaseEntryAccess().getWSTerminalRuleCall_1());
		match_DatabaseEntry_WSTerminalRuleCall_3_q = new TokenAlias(false, true, grammarAccess.getDatabaseEntryAccess().getWSTerminalRuleCall_3());
		match_Dictionary_CommaKeyword_4_q = new TokenAlias(false, true, grammarAccess.getDictionaryAccess().getCommaKeyword_4());
		match_List_CommaKeyword_4_q = new TokenAlias(false, true, grammarAccess.getListAccess().getCommaKeyword_4());
		match_SpellCommand_CommaKeyword_1_2_a = new TokenAlias(true, true, grammarAccess.getSpellCommandAccess().getCommaKeyword_1_2());
		match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_a = new TokenAlias(true, true, grammarAccess.getSpellDatabaseAccess().getSkipNLAndComments2ParserRuleCall_1_1_1_1_0());
		match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_p = new TokenAlias(true, false, grammarAccess.getSpellDatabaseAccess().getSkipNLAndComments2ParserRuleCall_1_1_1_1_0());
		match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_2_q = new TokenAlias(false, true, grammarAccess.getSpellDatabaseAccess().getSkipNLAndComments2ParserRuleCall_1_2_2());
		match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_3_0_q = new TokenAlias(false, true, grammarAccess.getSpellDatabaseAccess().getSkipNLAndComments2ParserRuleCall_1_2_3_0());
		match_TCArgs_CommaKeyword_5_0_0_q = new TokenAlias(false, true, grammarAccess.getTCArgsAccess().getCommaKeyword_5_0_0());
		match_TCArgs_CommaKeyword_6_a = new TokenAlias(true, true, grammarAccess.getTCArgsAccess().getCommaKeyword_6());
		match_Tuple_CommaKeyword_4_q = new TokenAlias(false, true, grammarAccess.getTupleAccess().getCommaKeyword_4());
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (ruleCall.getRule() == grammarAccess.getCMDRule())
			return getCMDToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCOLONRule())
			return getCOLONToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDOLLARRule())
			return getDOLLARToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getLAMBDARule())
			return getLAMBDAToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPAUSERule())
			return getPAUSEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSPELLRule())
			return getSPELLToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSkipNLAndCommentsRule())
			return getSkipNLAndCommentsToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSkipNLAndComments2Rule())
			return getSkipNLAndComments2Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSkipped_NLRule())
			return getSkipped_NLToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTMRule())
			return getTMToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getWAITRule())
			return getWAITToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getWSRule())
			return getWSToken(semanticObject, ruleCall, node);
		return "";
	}
	
	/**
	 * terminal CMD : 'CMD';
	 */
	protected String getCMDToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "CMD";
	}
	
	/**
	 * terminal COLON : ':';
	 */
	protected String getCOLONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ":";
	}
	
	/**
	 * terminal DOLLAR: '$';
	 */
	protected String getDOLLARToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "$";
	}
	
	/**
	 * terminal LAMBDA : 'lambda';
	 */
	protected String getLAMBDAToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "lambda";
	}
	
	/**
	 * terminal PAUSE : 'PAUSE';
	 */
	protected String getPAUSEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "PAUSE";
	}
	
	/**
	 * terminal SPELL : 'SPELL';
	 */
	protected String getSPELLToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "SPELL";
	}
	
	/**
	 * SkipNLAndComments hidden():
	 * 	(WS|ML_COMMENT|SL_COMMENT|NL)*
	 * ;
	 */
	protected String getSkipNLAndCommentsToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "";
	}
	
	/**
	 * SkipNLAndComments2 hidden(WS,ML_COMMENT, SL_COMMENT):
	 * 	NL+
	 * 	=>SkipNLAndComments
	 * ;
	 */
	protected String getSkipNLAndComments2Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "\r";
	}
	
	/**
	 * Skipped_NL hidden(WS):
	 * 	('\\' NL)*
	 * ;
	 */
	protected String getSkipped_NLToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "";
	}
	
	/**
	 * terminal TM : 'TM';
	 */
	protected String getTMToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "TM";
	}
	
	/**
	 * terminal WAIT : 'WAIT';
	 */
	protected String getWAITToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "WAIT";
	}
	
	/**
	 * terminal WS			: (' '|'\t')+;
	 */
	protected String getWSToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return " ";
	}
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			if (match_CSVCommand_CommaKeyword_3_2_0_4_a.equals(syntax))
				emit_CSVCommand_CommaKeyword_3_2_0_4_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_CSVCommand_CommaKeyword_4_a.equals(syntax))
				emit_CSVCommand_CommaKeyword_4_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_CSVSpell_CommaKeyword_3_a.equals(syntax))
				emit_CSVSpell_CommaKeyword_3_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_CSVTelemetry_CommaKeyword_4_a.equals(syntax))
				emit_CSVTelemetry_CommaKeyword_4_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_DatabaseEntry_WSTerminalRuleCall_1_q.equals(syntax))
				emit_DatabaseEntry_WSTerminalRuleCall_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_DatabaseEntry_WSTerminalRuleCall_3_q.equals(syntax))
				emit_DatabaseEntry_WSTerminalRuleCall_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Dictionary_CommaKeyword_4_q.equals(syntax))
				emit_Dictionary_CommaKeyword_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_List_CommaKeyword_4_q.equals(syntax))
				emit_List_CommaKeyword_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SpellCommand_CommaKeyword_1_2_a.equals(syntax))
				emit_SpellCommand_CommaKeyword_1_2_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_a.equals(syntax))
				emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_p.equals(syntax))
				emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_p(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_2_q.equals(syntax))
				emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_2_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_3_0_q.equals(syntax))
				emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_3_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_TCArgs_CommaKeyword_5_0_0_q.equals(syntax))
				emit_TCArgs_CommaKeyword_5_0_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_TCArgs_CommaKeyword_6_a.equals(syntax))
				emit_TCArgs_CommaKeyword_6_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Tuple_CommaKeyword_4_q.equals(syntax))
				emit_Tuple_CommaKeyword_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

	/**
	 * Ambiguous syntax:
	 *     ','*
	 *
	 * This ambiguous syntax occurs at:
	 *     args+=TCArgs (ambiguity) ','* (rule end)
	 *     args+=TCArgs (ambiguity) SkipNLAndComments2 ',' ',' args+=TCArgs
	 */
	protected void emit_CSVCommand_CommaKeyword_3_2_0_4_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','*
	 *
	 * This ambiguous syntax occurs at:
	 *     args+=TCArgs ','* (ambiguity) (rule end)
	 *     args+=TCArgs (ambiguity) (rule end)
	 *     command=ID_STMT (ambiguity) (rule end)
	 */
	protected void emit_CSVCommand_CommaKeyword_4_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','*
	 *
	 * This ambiguous syntax occurs at:
	 *     cmd=SpellCommand (ambiguity) (rule end)
	 */
	protected void emit_CSVSpell_CommaKeyword_3_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','*
	 *
	 * This ambiguous syntax occurs at:
	 *     tmArg=TCArgs (ambiguity) (rule end)
	 */
	protected void emit_CSVTelemetry_CommaKeyword_4_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     WS?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=KeyValue (ambiguity) Skipped_NL WS? (rule end)
	 *     name=KeyValue (ambiguity) Skipped_NL WS? value=DatabaseValue
	 */
	protected void emit_DatabaseEntry_WSTerminalRuleCall_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     WS?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=KeyValue WS? Skipped_NL (ambiguity) (rule end)
	 *     name=KeyValue WS? Skipped_NL (ambiguity) value=DatabaseValue
	 */
	protected void emit_DatabaseEntry_WSTerminalRuleCall_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) '{' Skipped_NL (ambiguity) Skipped_NL '}' (rule start)
	 *     entries+=DictionaryEntry Skipped_NL Skipped_NL (ambiguity) Skipped_NL '}' (rule end)
	 */
	protected void emit_Dictionary_CommaKeyword_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) '[' Skipped_NL (ambiguity) Skipped_NL ']' (rule start)
	 *     values+=Atom Skipped_NL (ambiguity) Skipped_NL ']' (rule end)
	 *     values+=Atom Skipped_NL Skipped_NL (ambiguity) Skipped_NL ']' (rule end)
	 *     values+=ComplexValue Skipped_NL (ambiguity) Skipped_NL ']' (rule end)
	 *     values+=ComplexValue Skipped_NL Skipped_NL (ambiguity) Skipped_NL ']' (rule end)
	 */
	protected void emit_List_CommaKeyword_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','*
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) PAUSE (ambiguity) (rule start)
	 */
	protected void emit_SpellCommand_CommaKeyword_1_2_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     SkipNLAndComments2*
	 *
	 * This ambiguous syntax occurs at:
	 *     databaseEntry+=DatabaseEntry (ambiguity) SkipNLAndComments (rule end)
	 */
	protected void emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     SkipNLAndComments2+
	 *
	 * This ambiguous syntax occurs at:
	 *     databaseEntry+=DatabaseEntry (ambiguity) databaseEntry+=DatabaseEntry
	 */
	protected void emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_1_1_1_0_p(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     SkipNLAndComments2?
	 *
	 * This ambiguous syntax occurs at:
	 *     csvEntries+=CSVEntry (ambiguity) SkipNLAndComments (rule end)
	 *     csvEntries+=CSVEntry (ambiguity) SkipNLAndComments2? csvEntries+=CSVEntry
	 */
	protected void emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_2_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     SkipNLAndComments2?
	 *
	 * This ambiguous syntax occurs at:
	 *     csvEntries+=CSVEntry (ambiguity) csvEntries+=CSVEntry
	 *     csvEntries+=CSVEntry SkipNLAndComments2? (ambiguity) csvEntries+=CSVEntry
	 */
	protected void emit_SpellDatabase_SkipNLAndComments2ParserRuleCall_1_2_3_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','?
	 *
	 * This ambiguous syntax occurs at:
	 *     tcMod=STATE_EXPR (ambiguity) ','* (rule end)
	 */
	protected void emit_TCArgs_CommaKeyword_5_0_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','*
	 *
	 * This ambiguous syntax occurs at:
	 *     tcMod=STATE_EXPR ','? (ambiguity) (rule end)
	 *     tolerance=PosIntOrFloat (ambiguity) (rule end)
	 */
	protected void emit_TCArgs_CommaKeyword_6_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ','?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) '(' Skipped_NL (ambiguity) Skipped_NL ')' (rule start)
	 *     values+=Atom Skipped_NL (ambiguity) Skipped_NL ')' (rule end)
	 *     values+=Atom Skipped_NL Skipped_NL (ambiguity) Skipped_NL ')' (rule end)
	 *     values+=ComplexValue Skipped_NL (ambiguity) Skipped_NL ')' (rule end)
	 *     values+=ComplexValue Skipped_NL Skipped_NL (ambiguity) Skipped_NL ')' (rule end)
	 */
	protected void emit_Tuple_CommaKeyword_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
}
