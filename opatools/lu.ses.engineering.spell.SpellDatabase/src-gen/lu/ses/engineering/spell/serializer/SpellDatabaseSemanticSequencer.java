/*
 * generated by Xtext
 */
package lu.ses.engineering.spell.serializer;

import com.google.inject.Inject;
import java.util.Set;
import lu.ses.engineering.spell.services.SpellDatabaseGrammarAccess;
import lu.ses.engineering.spell.spellDatabase.AstriumDatabase;
import lu.ses.engineering.spell.spellDatabase.AstriumHeaderComment;
import lu.ses.engineering.spell.spellDatabase.AstriumHeaderEntry;
import lu.ses.engineering.spell.spellDatabase.AstriumSpellDatabase;
import lu.ses.engineering.spell.spellDatabase.AstriumVariableComment;
import lu.ses.engineering.spell.spellDatabase.AstriumVariableEntry;
import lu.ses.engineering.spell.spellDatabase.CSVCommand;
import lu.ses.engineering.spell.spellDatabase.CSVFile;
import lu.ses.engineering.spell.spellDatabase.CSVSpell;
import lu.ses.engineering.spell.spellDatabase.CSVTelemetry;
import lu.ses.engineering.spell.spellDatabase.DatabaseEntry;
import lu.ses.engineering.spell.spellDatabase.Date;
import lu.ses.engineering.spell.spellDatabase.Dicitonary;
import lu.ses.engineering.spell.spellDatabase.DictionaryEntry;
import lu.ses.engineering.spell.spellDatabase.Lambda_Stmt;
import lu.ses.engineering.spell.spellDatabase.List;
import lu.ses.engineering.spell.spellDatabase.PauseCommand;
import lu.ses.engineering.spell.spellDatabase.RelDate;
import lu.ses.engineering.spell.spellDatabase.SpellDatabase;
import lu.ses.engineering.spell.spellDatabase.SpellDatabasePackage;
import lu.ses.engineering.spell.spellDatabase.StringValue;
import lu.ses.engineering.spell.spellDatabase.TCArgs;
import lu.ses.engineering.spell.spellDatabase.Tuple;
import lu.ses.engineering.spell.spellDatabase.WaitCommand;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SpellDatabaseSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpellDatabaseGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpellDatabasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpellDatabasePackage.ASTRIUM_DATABASE:
				sequence_AstriumDatabase(context, (AstriumDatabase) semanticObject); 
				return; 
			case SpellDatabasePackage.ASTRIUM_HEADER_COMMENT:
				sequence_AstriumHeaderEntry(context, (AstriumHeaderComment) semanticObject); 
				return; 
			case SpellDatabasePackage.ASTRIUM_HEADER_ENTRY:
				sequence_AstriumHeaderEntry(context, (AstriumHeaderEntry) semanticObject); 
				return; 
			case SpellDatabasePackage.ASTRIUM_SPELL_DATABASE:
				sequence_SpellDatabase(context, (AstriumSpellDatabase) semanticObject); 
				return; 
			case SpellDatabasePackage.ASTRIUM_VARIABLE_COMMENT:
				sequence_AstriumVariableEntry(context, (AstriumVariableComment) semanticObject); 
				return; 
			case SpellDatabasePackage.ASTRIUM_VARIABLE_ENTRY:
				sequence_AstriumVariableEntry(context, (AstriumVariableEntry) semanticObject); 
				return; 
			case SpellDatabasePackage.BOOLEAN:
				sequence_Boolean(context, (lu.ses.engineering.spell.spellDatabase.Boolean) semanticObject); 
				return; 
			case SpellDatabasePackage.CSV_COMMAND:
				sequence_CSVCommand(context, (CSVCommand) semanticObject); 
				return; 
			case SpellDatabasePackage.CSV_FILE:
				sequence_SpellDatabase(context, (CSVFile) semanticObject); 
				return; 
			case SpellDatabasePackage.CSV_SPELL:
				sequence_CSVSpell(context, (CSVSpell) semanticObject); 
				return; 
			case SpellDatabasePackage.CSV_TELEMETRY:
				sequence_CSVTelemetry(context, (CSVTelemetry) semanticObject); 
				return; 
			case SpellDatabasePackage.DATABASE_ENTRY:
				sequence_DatabaseEntry(context, (DatabaseEntry) semanticObject); 
				return; 
			case SpellDatabasePackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case SpellDatabasePackage.DICITONARY:
				sequence_Dictionary(context, (Dicitonary) semanticObject); 
				return; 
			case SpellDatabasePackage.DICTIONARY_ENTRY:
				sequence_DictionaryEntry(context, (DictionaryEntry) semanticObject); 
				return; 
			case SpellDatabasePackage.LAMBDA_STMT:
				sequence_Lambda_Stmt(context, (Lambda_Stmt) semanticObject); 
				return; 
			case SpellDatabasePackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case SpellDatabasePackage.NUMBER:
				sequence_Number(context, (lu.ses.engineering.spell.spellDatabase.Number) semanticObject); 
				return; 
			case SpellDatabasePackage.PAUSE_COMMAND:
				sequence_SpellCommand(context, (PauseCommand) semanticObject); 
				return; 
			case SpellDatabasePackage.REL_DATE:
				sequence_RelDate(context, (RelDate) semanticObject); 
				return; 
			case SpellDatabasePackage.SPELL_DATABASE:
				sequence_SpellDatabase(context, (SpellDatabase) semanticObject); 
				return; 
			case SpellDatabasePackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case SpellDatabasePackage.TC_ARGS:
				sequence_TCArgs(context, (TCArgs) semanticObject); 
				return; 
			case SpellDatabasePackage.TUPLE:
				sequence_Tuple(context, (Tuple) semanticObject); 
				return; 
			case SpellDatabasePackage.WAIT_COMMAND:
				sequence_SpellCommand(context, (WaitCommand) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AstriumDatabase returns AstriumDatabase
	 *
	 * Constraint:
	 *     (entries+=AstriumHeaderEntry* entries+=AstriumVariableEntry*)
	 */
	protected void sequence_AstriumDatabase(ISerializationContext context, AstriumDatabase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstriumHeaderEntry returns AstriumHeaderComment
	 *
	 * Constraint:
	 *     comment=ASTRIUM_COMMENT
	 */
	protected void sequence_AstriumHeaderEntry(ISerializationContext context, AstriumHeaderComment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.ASTRIUM_HEADER_COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.ASTRIUM_HEADER_COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstriumHeaderEntryAccess().getCommentASTRIUM_COMMENTTerminalRuleCall_0_1_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstriumHeaderEntry returns AstriumHeaderEntry
	 *
	 * Constraint:
	 *     (name=ASTRIUM_ID (astriumTime=ASTRIUM_TIME | value=Atom | simpleValue=SINGLE_VALUE)?)
	 */
	protected void sequence_AstriumHeaderEntry(ISerializationContext context, AstriumHeaderEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstriumVariableEntry returns AstriumVariableComment
	 *
	 * Constraint:
	 *     comment=ASTRIUM_COMMENT
	 */
	protected void sequence_AstriumVariableEntry(ISerializationContext context, AstriumVariableComment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.ASTRIUM_VARIABLE_COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.ASTRIUM_VARIABLE_COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstriumVariableEntryAccess().getCommentASTRIUM_COMMENTTerminalRuleCall_0_1_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstriumVariableEntry returns AstriumVariableEntry
	 *
	 * Constraint:
	 *     (name=ASTRIUM_ID (astriumTime=ASTRIUM_TIME | value=Atom | simpleValue=SINGLE_VALUE)?)
	 */
	protected void sequence_AstriumVariableEntry(ISerializationContext context, AstriumVariableEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns Boolean
	 *     Atom returns Boolean
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     val=BOOL_EXPR
	 */
	protected void sequence_Boolean(ISerializationContext context, lu.ses.engineering.spell.spellDatabase.Boolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.ATOM__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.ATOM__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanAccess().getValBOOL_EXPRTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CSVEntry returns CSVCommand
	 *     CSVCommand returns CSVCommand
	 *
	 * Constraint:
	 *     (command=ID_STMT (args+=TCArgs args+=TCArgs*)?)
	 */
	protected void sequence_CSVCommand(ISerializationContext context, CSVCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CSVEntry returns CSVSpell
	 *     CSVSpell returns CSVSpell
	 *
	 * Constraint:
	 *     cmd=SpellCommand
	 */
	protected void sequence_CSVSpell(ISerializationContext context, CSVSpell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.CSV_SPELL__CMD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.CSV_SPELL__CMD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCSVSpellAccess().getCmdSpellCommandParserRuleCall_2_0(), semanticObject.getCmd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CSVEntry returns CSVTelemetry
	 *     CSVTelemetry returns CSVTelemetry
	 *
	 * Constraint:
	 *     tmArg=TCArgs
	 */
	protected void sequence_CSVTelemetry(ISerializationContext context, CSVTelemetry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.CSV_TELEMETRY__TM_ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.CSV_TELEMETRY__TM_ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCSVTelemetryAccess().getTmArgTCArgsParserRuleCall_3_0(), semanticObject.getTmArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseEntry returns DatabaseEntry
	 *
	 * Constraint:
	 *     (name=KeyValue value=DatabaseValue?)
	 */
	protected void sequence_DatabaseEntry(ISerializationContext context, DatabaseEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns Date
	 *     Date returns Date
	 *
	 * Constraint:
	 *     val=ABSTIME
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.DATE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.DATE__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateAccess().getValABSTIMEParserRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DictionaryEntry returns DictionaryEntry
	 *
	 * Constraint:
	 *     ((key=Atom | key=ComplexValue) (value=Atom | value=ComplexValue)?)
	 */
	protected void sequence_DictionaryEntry(ISerializationContext context, DictionaryEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns Dicitonary
	 *     ComplexValue returns Dicitonary
	 *     Dictionary returns Dicitonary
	 *
	 * Constraint:
	 *     (entries+=DictionaryEntry entries+=DictionaryEntry*)?
	 */
	protected void sequence_Dictionary(ISerializationContext context, Dicitonary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns Lambda_Stmt
	 *     Lambda_Stmt returns Lambda_Stmt
	 *     Atom returns Lambda_Stmt
	 *
	 * Constraint:
	 *     (variables=Lambda_Vars? val=Lambda_Function?)
	 */
	protected void sequence_Lambda_Stmt(ISerializationContext context, Lambda_Stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns List
	 *     ComplexValue returns List
	 *     List returns List
	 *
	 * Constraint:
	 *     ((values+=Atom | values+=ComplexValue) values+=Atom? (values+=ComplexValue? values+=Atom?)*)?
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns Number
	 *     Atom returns Number
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (val=BIN_HEX_OCT | valInt=INTEGER | valStr=FLOAT_Val)
	 */
	protected void sequence_Number(ISerializationContext context, lu.ses.engineering.spell.spellDatabase.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns RelDate
	 *     RelDate returns RelDate
	 *
	 * Constraint:
	 *     val=RELTIME
	 */
	protected void sequence_RelDate(ISerializationContext context, RelDate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.REL_DATE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.REL_DATE__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelDateAccess().getValRELTIMEParserRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpellCommand returns PauseCommand
	 *
	 * Constraint:
	 *     {PauseCommand}
	 */
	protected void sequence_SpellCommand(ISerializationContext context, PauseCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpellCommand returns WaitCommand
	 *
	 * Constraint:
	 *     (value=IntOrFloat unit=TIME_EXPR)
	 */
	protected void sequence_SpellCommand(ISerializationContext context, WaitCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.WAIT_COMMAND__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.WAIT_COMMAND__VALUE));
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.WAIT_COMMAND__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.WAIT_COMMAND__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpellCommandAccess().getValueIntOrFloatParserRuleCall_0_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getSpellCommandAccess().getUnitTIME_EXPRTerminalRuleCall_0_5_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpellDatabase returns AstriumSpellDatabase
	 *
	 * Constraint:
	 *     database=AstriumDatabase
	 */
	protected void sequence_SpellDatabase(ISerializationContext context, AstriumSpellDatabase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.ASTRIUM_SPELL_DATABASE__DATABASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.ASTRIUM_SPELL_DATABASE__DATABASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpellDatabaseAccess().getDatabaseAstriumDatabaseParserRuleCall_1_0_3_0(), semanticObject.getDatabase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpellDatabase returns CSVFile
	 *
	 * Constraint:
	 *     (csvEntries+=CSVEntry csvEntries+=CSVEntry*)
	 */
	protected void sequence_SpellDatabase(ISerializationContext context, CSVFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpellDatabase returns SpellDatabase
	 *
	 * Constraint:
	 *     (databaseEntry+=DatabaseEntry databaseEntry+=DatabaseEntry*)
	 */
	protected void sequence_SpellDatabase(ISerializationContext context, SpellDatabase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns StringValue
	 *     Atom returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellDatabasePackage.Literals.ATOM__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellDatabasePackage.Literals.ATOM__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValSTRINGTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TCArgs returns TCArgs
	 *
	 * Constraint:
	 *     (tcName=TCValue tcValue=TCValue tcMod=STATE_EXPR tolerance=PosIntOrFloat?)
	 */
	protected void sequence_TCArgs(ISerializationContext context, TCArgs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DatabaseValue returns Tuple
	 *     ComplexValue returns Tuple
	 *     Tuple returns Tuple
	 *
	 * Constraint:
	 *     ((values+=Atom | values+=ComplexValue) values+=Atom? (values+=ComplexValue? values+=Atom?)*)?
	 */
	protected void sequence_Tuple(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
