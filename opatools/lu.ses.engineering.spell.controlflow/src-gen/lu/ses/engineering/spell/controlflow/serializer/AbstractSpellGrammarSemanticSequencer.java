/*
 * generated by Xtext
 */
package lu.ses.engineering.spell.controlflow.serializer;

import com.google.inject.Inject;
import java.util.Set;
import lu.ses.engineering.spell.controlflow.services.SpellGrammarGrammarAccess;
import lu.ses.engineering.spell.controlflow.spell.BuildTC;
import lu.ses.engineering.spell.controlflow.spell.ChangeLanguageConfig;
import lu.ses.engineering.spell.controlflow.spell.DisplayStep;
import lu.ses.engineering.spell.controlflow.spell.GetTM;
import lu.ses.engineering.spell.controlflow.spell.Goto;
import lu.ses.engineering.spell.controlflow.spell.Send;
import lu.ses.engineering.spell.controlflow.spell.SetLimits;
import lu.ses.engineering.spell.controlflow.spell.ShowTM;
import lu.ses.engineering.spell.controlflow.spell.SpellPackage;
import lu.ses.engineering.spell.controlflow.spell.Step;
import lu.ses.engineering.spell.controlflow.spell.Verify;
import lu.ses.engineering.spell.controlflow.spell.and_expr;
import lu.ses.engineering.spell.controlflow.spell.and_test;
import lu.ses.engineering.spell.controlflow.spell.arglist;
import lu.ses.engineering.spell.controlflow.spell.argument;
import lu.ses.engineering.spell.controlflow.spell.arith_expr;
import lu.ses.engineering.spell.controlflow.spell.assert_stmt;
import lu.ses.engineering.spell.controlflow.spell.assignment_stmt;
import lu.ses.engineering.spell.controlflow.spell.atom;
import lu.ses.engineering.spell.controlflow.spell.break_stmt;
import lu.ses.engineering.spell.controlflow.spell.classdef;
import lu.ses.engineering.spell.controlflow.spell.comp_for;
import lu.ses.engineering.spell.controlflow.spell.comp_if;
import lu.ses.engineering.spell.controlflow.spell.comparison;
import lu.ses.engineering.spell.controlflow.spell.continue_stmt;
import lu.ses.engineering.spell.controlflow.spell.decorated;
import lu.ses.engineering.spell.controlflow.spell.decorator;
import lu.ses.engineering.spell.controlflow.spell.decorators;
import lu.ses.engineering.spell.controlflow.spell.del_stmt;
import lu.ses.engineering.spell.controlflow.spell.dictorset_entry;
import lu.ses.engineering.spell.controlflow.spell.dictorsetmaker;
import lu.ses.engineering.spell.controlflow.spell.dotted_as_name;
import lu.ses.engineering.spell.controlflow.spell.dotted_as_names;
import lu.ses.engineering.spell.controlflow.spell.else_if_stmt;
import lu.ses.engineering.spell.controlflow.spell.eval_input;
import lu.ses.engineering.spell.controlflow.spell.except_clause;
import lu.ses.engineering.spell.controlflow.spell.exec_stmt;
import lu.ses.engineering.spell.controlflow.spell.expr;
import lu.ses.engineering.spell.controlflow.spell.expr_stmt;
import lu.ses.engineering.spell.controlflow.spell.exprlist;
import lu.ses.engineering.spell.controlflow.spell.factor;
import lu.ses.engineering.spell.controlflow.spell.file_input;
import lu.ses.engineering.spell.controlflow.spell.for_stmt;
import lu.ses.engineering.spell.controlflow.spell.fpdef;
import lu.ses.engineering.spell.controlflow.spell.fplist;
import lu.ses.engineering.spell.controlflow.spell.funcdef;
import lu.ses.engineering.spell.controlflow.spell.global_stmt;
import lu.ses.engineering.spell.controlflow.spell.if_stmt;
import lu.ses.engineering.spell.controlflow.spell.import_as_name;
import lu.ses.engineering.spell.controlflow.spell.import_as_names;
import lu.ses.engineering.spell.controlflow.spell.import_from;
import lu.ses.engineering.spell.controlflow.spell.import_name;
import lu.ses.engineering.spell.controlflow.spell.lambdef;
import lu.ses.engineering.spell.controlflow.spell.list_for;
import lu.ses.engineering.spell.controlflow.spell.list_if;
import lu.ses.engineering.spell.controlflow.spell.listmaker;
import lu.ses.engineering.spell.controlflow.spell.not_test;
import lu.ses.engineering.spell.controlflow.spell.or_test;
import lu.ses.engineering.spell.controlflow.spell.parameters;
import lu.ses.engineering.spell.controlflow.spell.pass_stmt;
import lu.ses.engineering.spell.controlflow.spell.power;
import lu.ses.engineering.spell.controlflow.spell.raise_stmt;
import lu.ses.engineering.spell.controlflow.spell.return_stmt;
import lu.ses.engineering.spell.controlflow.spell.shift_expr;
import lu.ses.engineering.spell.controlflow.spell.simple_stmt;
import lu.ses.engineering.spell.controlflow.spell.single_input;
import lu.ses.engineering.spell.controlflow.spell.sliceop;
import lu.ses.engineering.spell.controlflow.spell.subscript;
import lu.ses.engineering.spell.controlflow.spell.subscriptlist;
import lu.ses.engineering.spell.controlflow.spell.suite;
import lu.ses.engineering.spell.controlflow.spell.term;
import lu.ses.engineering.spell.controlflow.spell.test;
import lu.ses.engineering.spell.controlflow.spell.testlist;
import lu.ses.engineering.spell.controlflow.spell.testlist1;
import lu.ses.engineering.spell.controlflow.spell.testlist_comp;
import lu.ses.engineering.spell.controlflow.spell.testlist_safe;
import lu.ses.engineering.spell.controlflow.spell.trailer;
import lu.ses.engineering.spell.controlflow.spell.try_stmt;
import lu.ses.engineering.spell.controlflow.spell.varargslist;
import lu.ses.engineering.spell.controlflow.spell.varargslist_element;
import lu.ses.engineering.spell.controlflow.spell.while_stmt;
import lu.ses.engineering.spell.controlflow.spell.with_item;
import lu.ses.engineering.spell.controlflow.spell.with_stmt;
import lu.ses.engineering.spell.controlflow.spell.xor_expr;
import lu.ses.engineering.spell.controlflow.spell.yield_expr;
import lu.ses.engineering.spell.controlflow.spell.yield_stmt;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractSpellGrammarSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpellGrammarGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpellPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpellPackage.BUILD_TC:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (BuildTC) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (BuildTC) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.CHANGE_LANGUAGE_CONFIG:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (ChangeLanguageConfig) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (ChangeLanguageConfig) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.DISPLAY_STEP:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (DisplayStep) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (DisplayStep) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.GET_TM:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (GetTM) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (GetTM) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.GOTO:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (Goto) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (Goto) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.SEND:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (Send) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (Send) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.SET_LIMITS:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (SetLimits) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (SetLimits) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.SHOW_TM:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (ShowTM) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (ShowTM) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.STEP:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (Step) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (Step) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.VERIFY:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (Verify) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (Verify) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.AND_EXPR:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_and_expr(context, (and_expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_and_expr_testlist(context, (and_expr) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.AND_TEST:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_and_test(context, (and_test) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_and_test_testlist(context, (and_test) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.ARGLIST:
				sequence_arglist(context, (arglist) semanticObject); 
				return; 
			case SpellPackage.ARGUMENT:
				sequence_argument(context, (argument) semanticObject); 
				return; 
			case SpellPackage.ARITH_EXPR:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_arith_expr(context, (arith_expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_arith_expr_testlist(context, (arith_expr) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.ASSERT_STMT:
				sequence_assert_stmt(context, (assert_stmt) semanticObject); 
				return; 
			case SpellPackage.ASSIGNMENT_STMT:
				sequence_expr_stmt(context, (assignment_stmt) semanticObject); 
				return; 
			case SpellPackage.ATOM:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getPowerAccess().getPowerAtomAction_13_1_0()
						|| rule == grammarAccess.getAtomRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_atom(context, (atom) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_atom_testlist(context, (atom) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.BREAK_STMT:
				sequence_break_stmt(context, (break_stmt) semanticObject); 
				return; 
			case SpellPackage.CLASSDEF:
				sequence_classdef(context, (classdef) semanticObject); 
				return; 
			case SpellPackage.COMP_FOR:
				sequence_comp_for(context, (comp_for) semanticObject); 
				return; 
			case SpellPackage.COMP_IF:
				sequence_comp_if(context, (comp_if) semanticObject); 
				return; 
			case SpellPackage.COMPARISON:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_comparison(context, (comparison) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_comparison_testlist(context, (comparison) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.CONTINUE_STMT:
				sequence_continue_stmt(context, (continue_stmt) semanticObject); 
				return; 
			case SpellPackage.DECORATED:
				sequence_decorated(context, (decorated) semanticObject); 
				return; 
			case SpellPackage.DECORATOR:
				sequence_decorator(context, (decorator) semanticObject); 
				return; 
			case SpellPackage.DECORATORS:
				sequence_decorators(context, (decorators) semanticObject); 
				return; 
			case SpellPackage.DEL_STMT:
				sequence_del_stmt(context, (del_stmt) semanticObject); 
				return; 
			case SpellPackage.DICTORSET_ENTRY:
				sequence_dictorset_entry(context, (dictorset_entry) semanticObject); 
				return; 
			case SpellPackage.DICTORSETMAKER:
				sequence_dictorsetmaker(context, (dictorsetmaker) semanticObject); 
				return; 
			case SpellPackage.DOTTED_AS_NAME:
				sequence_dotted_as_name(context, (dotted_as_name) semanticObject); 
				return; 
			case SpellPackage.DOTTED_AS_NAMES:
				sequence_dotted_as_names(context, (dotted_as_names) semanticObject); 
				return; 
			case SpellPackage.ELSE_IF_STMT:
				sequence_else_if_stmt(context, (else_if_stmt) semanticObject); 
				return; 
			case SpellPackage.EVAL_INPUT:
				sequence_eval_input(context, (eval_input) semanticObject); 
				return; 
			case SpellPackage.EXCEPT_CLAUSE:
				sequence_except_clause(context, (except_clause) semanticObject); 
				return; 
			case SpellPackage.EXEC_STMT:
				sequence_exec_stmt(context, (exec_stmt) semanticObject); 
				return; 
			case SpellPackage.EXPR:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_expr(context, (expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_expr_testlist(context, (expr) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.EXPR_STMT:
				sequence_expr_stmt(context, (expr_stmt) semanticObject); 
				return; 
			case SpellPackage.EXPRLIST:
				sequence_exprlist(context, (exprlist) semanticObject); 
				return; 
			case SpellPackage.FACTOR:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_factor(context, (factor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_factor_testlist(context, (factor) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.FILE_INPUT:
				sequence_file_input(context, (file_input) semanticObject); 
				return; 
			case SpellPackage.FOR_STMT:
				sequence_for_stmt(context, (for_stmt) semanticObject); 
				return; 
			case SpellPackage.FPDEF:
				sequence_fpdef(context, (fpdef) semanticObject); 
				return; 
			case SpellPackage.FPLIST:
				sequence_fplist(context, (fplist) semanticObject); 
				return; 
			case SpellPackage.FUNCDEF:
				sequence_funcdef(context, (funcdef) semanticObject); 
				return; 
			case SpellPackage.GLOBAL_STMT:
				sequence_global_stmt(context, (global_stmt) semanticObject); 
				return; 
			case SpellPackage.IF_STMT:
				sequence_if_stmt(context, (if_stmt) semanticObject); 
				return; 
			case SpellPackage.IMPORT_AS_NAME:
				sequence_import_as_name(context, (import_as_name) semanticObject); 
				return; 
			case SpellPackage.IMPORT_AS_NAMES:
				sequence_import_as_names(context, (import_as_names) semanticObject); 
				return; 
			case SpellPackage.IMPORT_FROM:
				sequence_import_from(context, (import_from) semanticObject); 
				return; 
			case SpellPackage.IMPORT_NAME:
				sequence_import_name(context, (import_name) semanticObject); 
				return; 
			case SpellPackage.LAMBDEF:
				if (rule == grammarAccess.getTestRule()
						|| rule == grammarAccess.getLambdefRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_lambdef(context, (lambdef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_lambdef_testlist(context, (lambdef) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.LIST_FOR:
				sequence_list_for(context, (list_for) semanticObject); 
				return; 
			case SpellPackage.LIST_IF:
				sequence_list_if(context, (list_if) semanticObject); 
				return; 
			case SpellPackage.LISTMAKER:
				sequence_listmaker(context, (listmaker) semanticObject); 
				return; 
			case SpellPackage.NOT_TEST:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_not_test(context, (not_test) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_not_test_testlist(context, (not_test) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.OR_TEST:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_or_test(context, (or_test) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_or_test_testlist(context, (or_test) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.PARAMETERS:
				sequence_parameters(context, (parameters) semanticObject); 
				return; 
			case SpellPackage.PASS_STMT:
				sequence_pass_stmt(context, (pass_stmt) semanticObject); 
				return; 
			case SpellPackage.POWER:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| rule == grammarAccess.getPowerRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_power(context, (power) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_power_testlist(context, (power) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.RAISE_STMT:
				sequence_raise_stmt(context, (raise_stmt) semanticObject); 
				return; 
			case SpellPackage.RETURN_STMT:
				sequence_return_stmt(context, (return_stmt) semanticObject); 
				return; 
			case SpellPackage.SHIFT_EXPR:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_shift_expr(context, (shift_expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_shift_expr_testlist(context, (shift_expr) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.SIMPLE_STMT:
				sequence_simple_stmt(context, (simple_stmt) semanticObject); 
				return; 
			case SpellPackage.SINGLE_INPUT:
				sequence_single_input(context, (single_input) semanticObject); 
				return; 
			case SpellPackage.SLICEOP:
				sequence_sliceop(context, (sliceop) semanticObject); 
				return; 
			case SpellPackage.SUBSCRIPT:
				sequence_subscript(context, (subscript) semanticObject); 
				return; 
			case SpellPackage.SUBSCRIPTLIST:
				sequence_subscriptlist(context, (subscriptlist) semanticObject); 
				return; 
			case SpellPackage.SUITE:
				sequence_suite(context, (suite) semanticObject); 
				return; 
			case SpellPackage.TERM:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| rule == grammarAccess.getAnd_exprRule()
						|| action == grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0()
						|| rule == grammarAccess.getShift_exprRule()
						|| action == grammarAccess.getShift_exprAccess().getShift_exprLeftAction_1_0()
						|| rule == grammarAccess.getArith_exprRule()
						|| action == grammarAccess.getArith_exprAccess().getArith_exprLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_term(context, (term) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_term_testlist(context, (term) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.TEST:
				if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_test(context, (test) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_test_testlist(context, (test) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.TESTLIST:
				if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_testlist(context, (testlist) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()) {
					sequence_testlist_testlist_1_0(context, (testlist) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.TESTLIST1:
				sequence_testlist1(context, (testlist1) semanticObject); 
				return; 
			case SpellPackage.TESTLIST_COMP:
				sequence_testlist_comp(context, (testlist_comp) semanticObject); 
				return; 
			case SpellPackage.TESTLIST_SAFE:
				sequence_testlist_safe(context, (testlist_safe) semanticObject); 
				return; 
			case SpellPackage.TRAILER:
				sequence_trailer(context, (trailer) semanticObject); 
				return; 
			case SpellPackage.TRY_STMT:
				sequence_try_stmt(context, (try_stmt) semanticObject); 
				return; 
			case SpellPackage.VARARGSLIST:
				sequence_varargslist(context, (varargslist) semanticObject); 
				return; 
			case SpellPackage.VARARGSLIST_ELEMENT:
				sequence_varargslist_element(context, (varargslist_element) semanticObject); 
				return; 
			case SpellPackage.WHILE_STMT:
				sequence_while_stmt(context, (while_stmt) semanticObject); 
				return; 
			case SpellPackage.WITH_ITEM:
				sequence_with_item(context, (with_item) semanticObject); 
				return; 
			case SpellPackage.WITH_STMT:
				sequence_with_stmt(context, (with_stmt) semanticObject); 
				return; 
			case SpellPackage.XOR_EXPR:
				if (rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getSimple_stmtRule()
						|| action == grammarAccess.getSimple_stmtAccess().getSimple_stmtStmtAction_1_0()
						|| rule == grammarAccess.getSmall_stmtRule()
						|| rule == grammarAccess.getExpr_stmtRule()
						|| action == grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0()
						|| action == grammarAccess.getExpr_stmtAccess().getAssignment_stmtLeftAction_1_1_0()
						|| rule == grammarAccess.getYield_or_testlistRule()
						|| rule == grammarAccess.getTestlistRule()) {
					sequence_testlist_xor_expr(context, (xor_expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTestRule()
						|| action == grammarAccess.getTestAccess().getTestLeftAction_0_1_0()
						|| rule == grammarAccess.getOr_testRule()
						|| action == grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0()
						|| rule == grammarAccess.getAnd_testRule()
						|| action == grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0()
						|| rule == grammarAccess.getNot_testRule()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExprRule()
						|| action == grammarAccess.getExprAccess().getExprLeftAction_1_0()
						|| rule == grammarAccess.getXor_exprRule()
						|| action == grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0()
						|| action == grammarAccess.getTestlistAccess().getTestlistTestsAction_1_0()
						|| rule == grammarAccess.getArgumentRule()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_0_0()
						|| action == grammarAccess.getArgumentAccess().getArgumentTestAction_1_1_0()) {
					sequence_xor_expr(context, (xor_expr) semanticObject); 
					return; 
				}
				else break;
			case SpellPackage.YIELD_EXPR:
				sequence_yield_expr(context, (yield_expr) semanticObject); 
				return; 
			case SpellPackage.YIELD_STMT:
				sequence_yield_stmt(context, (yield_stmt) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     test returns and_expr
	 *     test.test_0_1_0 returns and_expr
	 *     or_test returns and_expr
	 *     or_test.or_test_1_0 returns and_expr
	 *     and_test returns and_expr
	 *     and_test.and_test_1_0 returns and_expr
	 *     not_test returns and_expr
	 *     comparison returns and_expr
	 *     comparison.comparison_1_0 returns and_expr
	 *     expr returns and_expr
	 *     expr.expr_1_0 returns and_expr
	 *     xor_expr returns and_expr
	 *     xor_expr.xor_expr_1_0 returns and_expr
	 *     and_expr returns and_expr
	 *     and_expr.and_expr_1_0 returns and_expr
	 *     testlist.testlist_1_0 returns and_expr
	 *     argument returns and_expr
	 *     argument.argument_1_0_0 returns and_expr
	 *     argument.argument_1_1_0 returns and_expr
	 *
	 * Constraint:
	 *     (left=and_expr_and_expr_1_0 sign='&' right=shift_expr)
	 */
	protected void sequence_and_expr(ISerializationContext context, and_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.OR_TEST__SIGN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.OR_TEST__SIGN));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_exprAccess().getAnd_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAnd_exprAccess().getSignAmpersandKeyword_1_1_0(), semanticObject.getSign());
		feeder.accept(grammarAccess.getAnd_exprAccess().getRightShift_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns and_expr
	 *     simple_stmt returns and_expr
	 *     simple_stmt.simple_stmt_1_0 returns and_expr
	 *     small_stmt returns and_expr
	 *     expr_stmt returns and_expr
	 *     expr_stmt.expr_stmt_1_0_0 returns and_expr
	 *     expr_stmt.assignment_stmt_1_1_0 returns and_expr
	 *     yield_or_testlist returns and_expr
	 *     testlist returns and_expr
	 *
	 * Constraint:
	 *     (left=and_expr_and_expr_1_0 sign='&' right=shift_expr optionalComma?=','?)
	 */
	protected void sequence_and_expr_testlist(ISerializationContext context, and_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns and_test
	 *     test.test_0_1_0 returns and_test
	 *     or_test returns and_test
	 *     or_test.or_test_1_0 returns and_test
	 *     and_test returns and_test
	 *     and_test.and_test_1_0 returns and_test
	 *     testlist.testlist_1_0 returns and_test
	 *     argument returns and_test
	 *     argument.argument_1_0_0 returns and_test
	 *     argument.argument_1_1_0 returns and_test
	 *
	 * Constraint:
	 *     (left=and_test_and_test_1_0 sign='and' right=not_test)
	 */
	protected void sequence_and_test(ISerializationContext context, and_test semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.OR_TEST__SIGN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.OR_TEST__SIGN));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_testAccess().getAnd_testLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAnd_testAccess().getSignAndKeyword_1_1_0(), semanticObject.getSign());
		feeder.accept(grammarAccess.getAnd_testAccess().getRightNot_testParserRuleCall_1_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns and_test
	 *     simple_stmt returns and_test
	 *     simple_stmt.simple_stmt_1_0 returns and_test
	 *     small_stmt returns and_test
	 *     expr_stmt returns and_test
	 *     expr_stmt.expr_stmt_1_0_0 returns and_test
	 *     expr_stmt.assignment_stmt_1_1_0 returns and_test
	 *     yield_or_testlist returns and_test
	 *     testlist returns and_test
	 *
	 * Constraint:
	 *     (left=and_test_and_test_1_0 sign='and' right=not_test optionalComma?=','?)
	 */
	protected void sequence_and_test_testlist(ISerializationContext context, and_test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     arglist returns arglist
	 *
	 * Constraint:
	 *     (
	 *         arguments+=argument* 
	 *         ((arguments+=argument optionalComma?=','?) | (dot1_test=test dot1_arguments+=argument* dot2_test=test?) | dot2_test=test)
	 *     )
	 */
	protected void sequence_arglist(ISerializationContext context, arglist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     argument returns argument
	 *
	 * Constraint:
	 *     ((test=argument_argument_1_0_0 comp_for=comp_for) | (test=argument_argument_1_1_0 test2=test))
	 */
	protected void sequence_argument(ISerializationContext context, argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns arith_expr
	 *     test.test_0_1_0 returns arith_expr
	 *     or_test returns arith_expr
	 *     or_test.or_test_1_0 returns arith_expr
	 *     and_test returns arith_expr
	 *     and_test.and_test_1_0 returns arith_expr
	 *     not_test returns arith_expr
	 *     comparison returns arith_expr
	 *     comparison.comparison_1_0 returns arith_expr
	 *     expr returns arith_expr
	 *     expr.expr_1_0 returns arith_expr
	 *     xor_expr returns arith_expr
	 *     xor_expr.xor_expr_1_0 returns arith_expr
	 *     and_expr returns arith_expr
	 *     and_expr.and_expr_1_0 returns arith_expr
	 *     shift_expr returns arith_expr
	 *     shift_expr.shift_expr_1_0 returns arith_expr
	 *     arith_expr returns arith_expr
	 *     arith_expr.arith_expr_1_0 returns arith_expr
	 *     testlist.testlist_1_0 returns arith_expr
	 *     argument returns arith_expr
	 *     argument.argument_1_0_0 returns arith_expr
	 *     argument.argument_1_1_0 returns arith_expr
	 *
	 * Constraint:
	 *     (left=arith_expr_arith_expr_1_0 (sign='+' | sign='-') right=term)
	 */
	protected void sequence_arith_expr(ISerializationContext context, arith_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns arith_expr
	 *     simple_stmt returns arith_expr
	 *     simple_stmt.simple_stmt_1_0 returns arith_expr
	 *     small_stmt returns arith_expr
	 *     expr_stmt returns arith_expr
	 *     expr_stmt.expr_stmt_1_0_0 returns arith_expr
	 *     expr_stmt.assignment_stmt_1_1_0 returns arith_expr
	 *     yield_or_testlist returns arith_expr
	 *     testlist returns arith_expr
	 *
	 * Constraint:
	 *     (left=arith_expr_arith_expr_1_0 (sign='+' | sign='-') right=term optionalComma?=','?)
	 */
	protected void sequence_arith_expr_testlist(ISerializationContext context, arith_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns assert_stmt
	 *     simple_stmt returns assert_stmt
	 *     simple_stmt.simple_stmt_1_0 returns assert_stmt
	 *     small_stmt returns assert_stmt
	 *     assert_stmt returns assert_stmt
	 *
	 * Constraint:
	 *     (assers+=test assers+=test?)
	 */
	protected void sequence_assert_stmt(ISerializationContext context, assert_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns atom
	 *     test.test_0_1_0 returns atom
	 *     or_test returns atom
	 *     or_test.or_test_1_0 returns atom
	 *     and_test returns atom
	 *     and_test.and_test_1_0 returns atom
	 *     not_test returns atom
	 *     comparison returns atom
	 *     comparison.comparison_1_0 returns atom
	 *     expr returns atom
	 *     expr.expr_1_0 returns atom
	 *     xor_expr returns atom
	 *     xor_expr.xor_expr_1_0 returns atom
	 *     and_expr returns atom
	 *     and_expr.and_expr_1_0 returns atom
	 *     shift_expr returns atom
	 *     shift_expr.shift_expr_1_0 returns atom
	 *     arith_expr returns atom
	 *     arith_expr.arith_expr_1_0 returns atom
	 *     term returns atom
	 *     term.term_1_0 returns atom
	 *     factor returns atom
	 *     power returns atom
	 *     power.power_13_1_0 returns atom
	 *     atom returns atom
	 *     testlist.testlist_1_0 returns atom
	 *     argument returns atom
	 *     argument.argument_1_0_0 returns atom
	 *     argument.argument_1_1_0 returns atom
	 *
	 * Constraint:
	 *     (
	 *         (roundBracket?='(' yield_or_testlist_comp=yield_or_testlist_comp?) | 
	 *         (squareBracket?='[' listmaker=listmaker?) | 
	 *         (curlyBracket?='{' dictorsetmaker=dictorsetmaker?) | 
	 *         testlist1=testlist1 | 
	 *         name=NAME | 
	 *         name=NumberWithPlusOrMinus | 
	 *         strings+=STRING+
	 *     )
	 */
	protected void sequence_atom(ISerializationContext context, atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns atom
	 *     simple_stmt returns atom
	 *     simple_stmt.simple_stmt_1_0 returns atom
	 *     small_stmt returns atom
	 *     expr_stmt returns atom
	 *     expr_stmt.expr_stmt_1_0_0 returns atom
	 *     expr_stmt.assignment_stmt_1_1_0 returns atom
	 *     yield_or_testlist returns atom
	 *     testlist returns atom
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (roundBracket?='(' yield_or_testlist_comp=yield_or_testlist_comp?) | 
	 *             (squareBracket?='[' listmaker=listmaker?) | 
	 *             (curlyBracket?='{' dictorsetmaker=dictorsetmaker?) | 
	 *             testlist1=testlist1 | 
	 *             name=NAME | 
	 *             name=NumberWithPlusOrMinus | 
	 *             strings+=STRING+
	 *         ) 
	 *         optionalComma?=','?
	 *     )
	 */
	protected void sequence_atom_testlist(ISerializationContext context, atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns break_stmt
	 *     simple_stmt returns break_stmt
	 *     simple_stmt.simple_stmt_1_0 returns break_stmt
	 *     small_stmt returns break_stmt
	 *     flow_stmt returns break_stmt
	 *     break_stmt returns break_stmt
	 *
	 * Constraint:
	 *     {break_stmt}
	 */
	protected void sequence_break_stmt(ISerializationContext context, break_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns classdef
	 *     compound_stmt returns classdef
	 *     classdef returns classdef
	 *
	 * Constraint:
	 *     (name=NAME (roundBrackets?='(' testlist=testlist)? suite=suite)
	 */
	protected void sequence_classdef(ISerializationContext context, classdef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     comp_iter returns comp_for
	 *     comp_for returns comp_for
	 *
	 * Constraint:
	 *     (exprlist=exprlist or_test=or_test comp_iter=comp_iter?)
	 */
	protected void sequence_comp_for(ISerializationContext context, comp_for semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     comp_iter returns comp_if
	 *     comp_if returns comp_if
	 *
	 * Constraint:
	 *     (test=test comp_iter=comp_iter?)
	 */
	protected void sequence_comp_if(ISerializationContext context, comp_if semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns comparison
	 *     test.test_0_1_0 returns comparison
	 *     or_test returns comparison
	 *     or_test.or_test_1_0 returns comparison
	 *     and_test returns comparison
	 *     and_test.and_test_1_0 returns comparison
	 *     not_test returns comparison
	 *     comparison returns comparison
	 *     comparison.comparison_1_0 returns comparison
	 *     testlist.testlist_1_0 returns comparison
	 *     argument returns comparison
	 *     argument.argument_1_0_0 returns comparison
	 *     argument.argument_1_1_0 returns comparison
	 *
	 * Constraint:
	 *     (left=comparison_comparison_1_0 comp_op=comp_op right=expr)
	 */
	protected void sequence_comparison(ISerializationContext context, comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.COMPARISON__COMP_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.COMPARISON__COMP_OP));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getComp_opComp_opParserRuleCall_1_1_0(), semanticObject.getComp_op());
		feeder.accept(grammarAccess.getComparisonAccess().getRightExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns comparison
	 *     simple_stmt returns comparison
	 *     simple_stmt.simple_stmt_1_0 returns comparison
	 *     small_stmt returns comparison
	 *     expr_stmt returns comparison
	 *     expr_stmt.expr_stmt_1_0_0 returns comparison
	 *     expr_stmt.assignment_stmt_1_1_0 returns comparison
	 *     yield_or_testlist returns comparison
	 *     testlist returns comparison
	 *
	 * Constraint:
	 *     (left=comparison_comparison_1_0 comp_op=comp_op right=expr optionalComma?=','?)
	 */
	protected void sequence_comparison_testlist(ISerializationContext context, comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns continue_stmt
	 *     simple_stmt returns continue_stmt
	 *     simple_stmt.simple_stmt_1_0 returns continue_stmt
	 *     small_stmt returns continue_stmt
	 *     flow_stmt returns continue_stmt
	 *     continue_stmt returns continue_stmt
	 *
	 * Constraint:
	 *     {continue_stmt}
	 */
	protected void sequence_continue_stmt(ISerializationContext context, continue_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     decorated returns decorated
	 *     stmt returns decorated
	 *     compound_stmt returns decorated
	 *
	 * Constraint:
	 *     (decorators=decorators (def=classdef | def=funcdef))
	 */
	protected void sequence_decorated(ISerializationContext context, decorated semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     decorator returns decorator
	 *
	 * Constraint:
	 *     (dotted_name=dotted_name (roundBracket?='(' arglist=arglist?)?)
	 */
	protected void sequence_decorator(ISerializationContext context, decorator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     decorators returns decorators
	 *
	 * Constraint:
	 *     decorators+=decorator+
	 */
	protected void sequence_decorators(ISerializationContext context, decorators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns del_stmt
	 *     simple_stmt returns del_stmt
	 *     simple_stmt.simple_stmt_1_0 returns del_stmt
	 *     small_stmt returns del_stmt
	 *     del_stmt returns del_stmt
	 *
	 * Constraint:
	 *     exprlist=exprlist
	 */
	protected void sequence_del_stmt(ISerializationContext context, del_stmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.DEL_STMT__EXPRLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.DEL_STMT__EXPRLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDel_stmtAccess().getExprlistExprlistParserRuleCall_1_0(), semanticObject.getExprlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     dictorset_entry returns dictorset_entry
	 *
	 * Constraint:
	 *     (test1=test test2=test)
	 */
	protected void sequence_dictorset_entry(ISerializationContext context, dictorset_entry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.DICTORSET_ENTRY__TEST1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.DICTORSET_ENTRY__TEST1));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.DICTORSET_ENTRY__TEST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.DICTORSET_ENTRY__TEST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDictorset_entryAccess().getTest1TestParserRuleCall_0_0(), semanticObject.getTest1());
		feeder.accept(grammarAccess.getDictorset_entryAccess().getTest2TestParserRuleCall_2_0(), semanticObject.getTest2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     dictorsetmaker returns dictorsetmaker
	 *
	 * Constraint:
	 *     (entries+=dictorset_entry (comp_for=comp_for | (entries+=dictorset_entry* optionalComma?=','?))?)
	 */
	protected void sequence_dictorsetmaker(ISerializationContext context, dictorsetmaker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     dotted_as_name returns dotted_as_name
	 *
	 * Constraint:
	 *     (name=dotted_name identifier=NAME?)
	 */
	protected void sequence_dotted_as_name(ISerializationContext context, dotted_as_name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     dotted_as_names returns dotted_as_names
	 *
	 * Constraint:
	 *     (dotted_names+=dotted_as_name dotted_names+=dotted_as_name*)
	 */
	protected void sequence_dotted_as_names(ISerializationContext context, dotted_as_names semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     else_if_stmt returns else_if_stmt
	 *
	 * Constraint:
	 *     (test=test suite=suite)
	 */
	protected void sequence_else_if_stmt(ISerializationContext context, else_if_stmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.ELSE_IF_STMT__TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.ELSE_IF_STMT__TEST));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.ELSE_IF_STMT__SUITE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.ELSE_IF_STMT__SUITE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElse_if_stmtAccess().getTestTestParserRuleCall_1_0(), semanticObject.getTest());
		feeder.accept(grammarAccess.getElse_if_stmtAccess().getSuiteSuiteParserRuleCall_3_0(), semanticObject.getSuite());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     python_input returns eval_input
	 *     eval_input returns eval_input
	 *
	 * Constraint:
	 *     testlist=testlist
	 */
	protected void sequence_eval_input(ISerializationContext context, eval_input semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EVAL_INPUT__TESTLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EVAL_INPUT__TESTLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEval_inputAccess().getTestlistTestlistParserRuleCall_1_0(), semanticObject.getTestlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     except_clause returns except_clause
	 *
	 * Constraint:
	 *     ((test=test ((sign='as' | sign=',') next_test=test)?)? suite=suite)
	 */
	protected void sequence_except_clause(ISerializationContext context, except_clause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns exec_stmt
	 *     simple_stmt returns exec_stmt
	 *     simple_stmt.simple_stmt_1_0 returns exec_stmt
	 *     small_stmt returns exec_stmt
	 *     exec_stmt returns exec_stmt
	 *
	 * Constraint:
	 *     (expr=expr (tests+=test tests+=test?)?)
	 */
	protected void sequence_exec_stmt(ISerializationContext context, exec_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns expr
	 *     test.test_0_1_0 returns expr
	 *     or_test returns expr
	 *     or_test.or_test_1_0 returns expr
	 *     and_test returns expr
	 *     and_test.and_test_1_0 returns expr
	 *     not_test returns expr
	 *     comparison returns expr
	 *     comparison.comparison_1_0 returns expr
	 *     expr returns expr
	 *     expr.expr_1_0 returns expr
	 *     testlist.testlist_1_0 returns expr
	 *     argument returns expr
	 *     argument.argument_1_0_0 returns expr
	 *     argument.argument_1_1_0 returns expr
	 *
	 * Constraint:
	 *     (left=expr_expr_1_0 sign='|' right=xor_expr)
	 */
	protected void sequence_expr(ISerializationContext context, expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.OR_TEST__SIGN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.OR_TEST__SIGN));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExprAccess().getExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExprAccess().getSignVerticalLineKeyword_1_1_0(), semanticObject.getSign());
		feeder.accept(grammarAccess.getExprAccess().getRightXor_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns assignment_stmt
	 *     simple_stmt returns assignment_stmt
	 *     simple_stmt.simple_stmt_1_0 returns assignment_stmt
	 *     small_stmt returns assignment_stmt
	 *     expr_stmt returns assignment_stmt
	 *
	 * Constraint:
	 *     (left=expr_stmt_assignment_stmt_1_1_0 (symbol='=' assignments+=yield_or_testlist)+)
	 */
	protected void sequence_expr_stmt(ISerializationContext context, assignment_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns expr_stmt
	 *     simple_stmt returns expr_stmt
	 *     simple_stmt.simple_stmt_1_0 returns expr_stmt
	 *     small_stmt returns expr_stmt
	 *     expr_stmt returns expr_stmt
	 *
	 * Constraint:
	 *     (left=expr_stmt_expr_stmt_1_0_0 symbol=augassign right=yield_or_testlist)
	 */
	protected void sequence_expr_stmt(ISerializationContext context, expr_stmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__SYMBOL));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpr_stmtAccess().getExpr_stmtLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpr_stmtAccess().getSymbolAugassignParserRuleCall_1_0_1_0(), semanticObject.getSymbol());
		feeder.accept(grammarAccess.getExpr_stmtAccess().getRightYield_or_testlistParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns expr
	 *     simple_stmt returns expr
	 *     simple_stmt.simple_stmt_1_0 returns expr
	 *     small_stmt returns expr
	 *     expr_stmt returns expr
	 *     expr_stmt.expr_stmt_1_0_0 returns expr
	 *     expr_stmt.assignment_stmt_1_1_0 returns expr
	 *     yield_or_testlist returns expr
	 *     testlist returns expr
	 *
	 * Constraint:
	 *     (left=expr_expr_1_0 sign='|' right=xor_expr optionalComma?=','?)
	 */
	protected void sequence_expr_testlist(ISerializationContext context, expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exprlist returns exprlist
	 *
	 * Constraint:
	 *     (exprs+=expr exprs+=expr* optionalComma?=','?)
	 */
	protected void sequence_exprlist(ISerializationContext context, exprlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns factor
	 *     test.test_0_1_0 returns factor
	 *     or_test returns factor
	 *     or_test.or_test_1_0 returns factor
	 *     and_test returns factor
	 *     and_test.and_test_1_0 returns factor
	 *     not_test returns factor
	 *     comparison returns factor
	 *     comparison.comparison_1_0 returns factor
	 *     expr returns factor
	 *     expr.expr_1_0 returns factor
	 *     xor_expr returns factor
	 *     xor_expr.xor_expr_1_0 returns factor
	 *     and_expr returns factor
	 *     and_expr.and_expr_1_0 returns factor
	 *     shift_expr returns factor
	 *     shift_expr.shift_expr_1_0 returns factor
	 *     arith_expr returns factor
	 *     arith_expr.arith_expr_1_0 returns factor
	 *     term returns factor
	 *     term.term_1_0 returns factor
	 *     factor returns factor
	 *     testlist.testlist_1_0 returns factor
	 *     argument returns factor
	 *     argument.argument_1_0_0 returns factor
	 *     argument.argument_1_1_0 returns factor
	 *
	 * Constraint:
	 *     ((sign='+' | sign='-' | sign='~') factor=factor)
	 */
	protected void sequence_factor(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns factor
	 *     simple_stmt returns factor
	 *     simple_stmt.simple_stmt_1_0 returns factor
	 *     small_stmt returns factor
	 *     expr_stmt returns factor
	 *     expr_stmt.expr_stmt_1_0_0 returns factor
	 *     expr_stmt.assignment_stmt_1_1_0 returns factor
	 *     yield_or_testlist returns factor
	 *     testlist returns factor
	 *
	 * Constraint:
	 *     ((sign='+' | sign='-' | sign='~') factor=factor optionalComma?=','?)
	 */
	protected void sequence_factor_testlist(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     file_input returns file_input
	 *     python_input returns file_input
	 *
	 * Constraint:
	 *     stmts+=stmt*
	 */
	protected void sequence_file_input(ISerializationContext context, file_input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns for_stmt
	 *     compound_stmt returns for_stmt
	 *     for_stmt returns for_stmt
	 *
	 * Constraint:
	 *     (exprlist=exprlist testlist=testlist suite=suite else=suite?)
	 */
	protected void sequence_for_stmt(ISerializationContext context, for_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fpdef returns fpdef
	 *
	 * Constraint:
	 *     (name=NAME | fplist=fplist)
	 */
	protected void sequence_fpdef(ISerializationContext context, fpdef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fplist returns fplist
	 *
	 * Constraint:
	 *     (def1=fpdef definitions+=fpdef* optionalSemicolon?=';'?)
	 */
	protected void sequence_fplist(ISerializationContext context, fplist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     funcdef returns funcdef
	 *     stmt returns funcdef
	 *     compound_stmt returns funcdef
	 *
	 * Constraint:
	 *     (name=NAME parameters=parameters suite=suite)
	 */
	protected void sequence_funcdef(ISerializationContext context, funcdef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.FUNCDEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.FUNCDEF__NAME));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.FUNCDEF__PARAMETERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.FUNCDEF__PARAMETERS));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.FUNCDEF__SUITE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.FUNCDEF__SUITE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncdefAccess().getNameNAMEParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFuncdefAccess().getParametersParametersParserRuleCall_2_0(), semanticObject.getParameters());
		feeder.accept(grammarAccess.getFuncdefAccess().getSuiteSuiteParserRuleCall_4_0(), semanticObject.getSuite());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns global_stmt
	 *     simple_stmt returns global_stmt
	 *     simple_stmt.simple_stmt_1_0 returns global_stmt
	 *     small_stmt returns global_stmt
	 *     global_stmt returns global_stmt
	 *
	 * Constraint:
	 *     (globals+=NAME globals+=NAME*)
	 */
	protected void sequence_global_stmt(ISerializationContext context, global_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns if_stmt
	 *     compound_stmt returns if_stmt
	 *     if_stmt returns if_stmt
	 *
	 * Constraint:
	 *     (test=test suite=suite else_if_stmts+=else_if_stmt* else=suite?)
	 */
	protected void sequence_if_stmt(ISerializationContext context, if_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     import_as_name returns import_as_name
	 *
	 * Constraint:
	 *     (name=NAME identifier=NAME?)
	 */
	protected void sequence_import_as_name(ISerializationContext context, import_as_name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     import_as_names returns import_as_names
	 *
	 * Constraint:
	 *     (imports+=import_as_name imports+=import_as_name* optionalComma?=','?)
	 */
	protected void sequence_import_as_names(ISerializationContext context, import_as_names semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns import_from
	 *     simple_stmt returns import_from
	 *     simple_stmt.simple_stmt_1_0 returns import_from
	 *     small_stmt returns import_from
	 *     import_stmt returns import_from
	 *     import_from returns import_from
	 *
	 * Constraint:
	 *     (((dots+='.'* dotted_name=dotted_name) | dots2+='.'+) ((roundBracket?='(' import_as_names=import_as_names) | import_as_names=import_as_names)?)
	 */
	protected void sequence_import_from(ISerializationContext context, import_from semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns import_name
	 *     simple_stmt returns import_name
	 *     simple_stmt.simple_stmt_1_0 returns import_name
	 *     small_stmt returns import_name
	 *     import_stmt returns import_name
	 *     import_name returns import_name
	 *
	 * Constraint:
	 *     dotted_as_names=dotted_as_names
	 */
	protected void sequence_import_name(ISerializationContext context, import_name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.IMPORT_NAME__DOTTED_AS_NAMES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.IMPORT_NAME__DOTTED_AS_NAMES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImport_nameAccess().getDotted_as_namesDotted_as_namesParserRuleCall_1_0(), semanticObject.getDotted_as_names());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     test returns lambdef
	 *     lambdef returns lambdef
	 *     testlist.testlist_1_0 returns lambdef
	 *     argument returns lambdef
	 *     argument.argument_1_0_0 returns lambdef
	 *     argument.argument_1_1_0 returns lambdef
	 *
	 * Constraint:
	 *     (varargslist=varargslist? test=test)
	 */
	protected void sequence_lambdef(ISerializationContext context, lambdef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns lambdef
	 *     simple_stmt returns lambdef
	 *     simple_stmt.simple_stmt_1_0 returns lambdef
	 *     small_stmt returns lambdef
	 *     expr_stmt returns lambdef
	 *     expr_stmt.expr_stmt_1_0_0 returns lambdef
	 *     expr_stmt.assignment_stmt_1_1_0 returns lambdef
	 *     yield_or_testlist returns lambdef
	 *     testlist returns lambdef
	 *
	 * Constraint:
	 *     (varargslist=varargslist? test=test optionalComma?=','?)
	 */
	protected void sequence_lambdef_testlist(ISerializationContext context, lambdef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     list_iter returns list_for
	 *     list_for returns list_for
	 *
	 * Constraint:
	 *     (exprlist=exprlist testlist_safe=testlist_safe list_iter=list_iter?)
	 */
	protected void sequence_list_for(ISerializationContext context, list_for semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     list_iter returns list_if
	 *     list_if returns list_if
	 *
	 * Constraint:
	 *     (old_test=test list_iter=list_iter?)
	 */
	protected void sequence_list_if(ISerializationContext context, list_if semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     listmaker returns listmaker
	 *
	 * Constraint:
	 *     (test=test (list_for=list_for | (additionalTests+=test* optionalComma?=','?))?)
	 */
	protected void sequence_listmaker(ISerializationContext context, listmaker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns not_test
	 *     test.test_0_1_0 returns not_test
	 *     or_test returns not_test
	 *     or_test.or_test_1_0 returns not_test
	 *     and_test returns not_test
	 *     and_test.and_test_1_0 returns not_test
	 *     not_test returns not_test
	 *     testlist.testlist_1_0 returns not_test
	 *     argument returns not_test
	 *     argument.argument_1_0_0 returns not_test
	 *     argument.argument_1_1_0 returns not_test
	 *
	 * Constraint:
	 *     (not+='not'+ comparison=comparison)
	 */
	protected void sequence_not_test(ISerializationContext context, not_test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns not_test
	 *     simple_stmt returns not_test
	 *     simple_stmt.simple_stmt_1_0 returns not_test
	 *     small_stmt returns not_test
	 *     expr_stmt returns not_test
	 *     expr_stmt.expr_stmt_1_0_0 returns not_test
	 *     expr_stmt.assignment_stmt_1_1_0 returns not_test
	 *     yield_or_testlist returns not_test
	 *     testlist returns not_test
	 *
	 * Constraint:
	 *     (not+='not'+ comparison=comparison optionalComma?=','?)
	 */
	protected void sequence_not_test_testlist(ISerializationContext context, not_test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns or_test
	 *     test.test_0_1_0 returns or_test
	 *     or_test returns or_test
	 *     or_test.or_test_1_0 returns or_test
	 *     testlist.testlist_1_0 returns or_test
	 *     argument returns or_test
	 *     argument.argument_1_0_0 returns or_test
	 *     argument.argument_1_1_0 returns or_test
	 *
	 * Constraint:
	 *     (left=or_test_or_test_1_0 sign='or' right=and_test)
	 */
	protected void sequence_or_test(ISerializationContext context, or_test semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.OR_TEST__SIGN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.OR_TEST__SIGN));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOr_testAccess().getOr_testLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOr_testAccess().getSignOrKeyword_1_1_0(), semanticObject.getSign());
		feeder.accept(grammarAccess.getOr_testAccess().getRightAnd_testParserRuleCall_1_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns or_test
	 *     simple_stmt returns or_test
	 *     simple_stmt.simple_stmt_1_0 returns or_test
	 *     small_stmt returns or_test
	 *     expr_stmt returns or_test
	 *     expr_stmt.expr_stmt_1_0_0 returns or_test
	 *     expr_stmt.assignment_stmt_1_1_0 returns or_test
	 *     yield_or_testlist returns or_test
	 *     testlist returns or_test
	 *
	 * Constraint:
	 *     (left=or_test_or_test_1_0 sign='or' right=and_test optionalComma?=','?)
	 */
	protected void sequence_or_test_testlist(ISerializationContext context, or_test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameters returns parameters
	 *
	 * Constraint:
	 *     varargslist=varargslist?
	 */
	protected void sequence_parameters(ISerializationContext context, parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns pass_stmt
	 *     simple_stmt returns pass_stmt
	 *     simple_stmt.simple_stmt_1_0 returns pass_stmt
	 *     small_stmt returns pass_stmt
	 *     pass_stmt returns pass_stmt
	 *
	 * Constraint:
	 *     {pass_stmt}
	 */
	protected void sequence_pass_stmt(ISerializationContext context, pass_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns BuildTC
	 *     test.test_0_1_0 returns BuildTC
	 *     or_test returns BuildTC
	 *     or_test.or_test_1_0 returns BuildTC
	 *     and_test returns BuildTC
	 *     and_test.and_test_1_0 returns BuildTC
	 *     not_test returns BuildTC
	 *     comparison returns BuildTC
	 *     comparison.comparison_1_0 returns BuildTC
	 *     expr returns BuildTC
	 *     expr.expr_1_0 returns BuildTC
	 *     xor_expr returns BuildTC
	 *     xor_expr.xor_expr_1_0 returns BuildTC
	 *     and_expr returns BuildTC
	 *     and_expr.and_expr_1_0 returns BuildTC
	 *     shift_expr returns BuildTC
	 *     shift_expr.shift_expr_1_0 returns BuildTC
	 *     arith_expr returns BuildTC
	 *     arith_expr.arith_expr_1_0 returns BuildTC
	 *     term returns BuildTC
	 *     term.term_1_0 returns BuildTC
	 *     factor returns BuildTC
	 *     power returns BuildTC
	 *     testlist.testlist_1_0 returns BuildTC
	 *     argument returns BuildTC
	 *     argument.argument_1_0_0 returns BuildTC
	 *     argument.argument_1_1_0 returns BuildTC
	 *
	 * Constraint:
	 *     (args+=arglist trailer+=trailer*)
	 */
	protected void sequence_power(ISerializationContext context, BuildTC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns ChangeLanguageConfig
	 *     test.test_0_1_0 returns ChangeLanguageConfig
	 *     or_test returns ChangeLanguageConfig
	 *     or_test.or_test_1_0 returns ChangeLanguageConfig
	 *     and_test returns ChangeLanguageConfig
	 *     and_test.and_test_1_0 returns ChangeLanguageConfig
	 *     not_test returns ChangeLanguageConfig
	 *     comparison returns ChangeLanguageConfig
	 *     comparison.comparison_1_0 returns ChangeLanguageConfig
	 *     expr returns ChangeLanguageConfig
	 *     expr.expr_1_0 returns ChangeLanguageConfig
	 *     xor_expr returns ChangeLanguageConfig
	 *     xor_expr.xor_expr_1_0 returns ChangeLanguageConfig
	 *     and_expr returns ChangeLanguageConfig
	 *     and_expr.and_expr_1_0 returns ChangeLanguageConfig
	 *     shift_expr returns ChangeLanguageConfig
	 *     shift_expr.shift_expr_1_0 returns ChangeLanguageConfig
	 *     arith_expr returns ChangeLanguageConfig
	 *     arith_expr.arith_expr_1_0 returns ChangeLanguageConfig
	 *     term returns ChangeLanguageConfig
	 *     term.term_1_0 returns ChangeLanguageConfig
	 *     factor returns ChangeLanguageConfig
	 *     power returns ChangeLanguageConfig
	 *     testlist.testlist_1_0 returns ChangeLanguageConfig
	 *     argument returns ChangeLanguageConfig
	 *     argument.argument_1_0_0 returns ChangeLanguageConfig
	 *     argument.argument_1_1_0 returns ChangeLanguageConfig
	 *
	 * Constraint:
	 *     (statement=Python_Statement args=arglist)
	 */
	protected void sequence_power(ISerializationContext context, ChangeLanguageConfig semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.CHANGE_LANGUAGE_CONFIG__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.CHANGE_LANGUAGE_CONFIG__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.CHANGE_LANGUAGE_CONFIG__ARGS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.CHANGE_LANGUAGE_CONFIG__ARGS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerAccess().getStatementPython_StatementParserRuleCall_12_3_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getPowerAccess().getArgsArglistParserRuleCall_12_5_0(), semanticObject.getArgs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     test returns DisplayStep
	 *     test.test_0_1_0 returns DisplayStep
	 *     or_test returns DisplayStep
	 *     or_test.or_test_1_0 returns DisplayStep
	 *     and_test returns DisplayStep
	 *     and_test.and_test_1_0 returns DisplayStep
	 *     not_test returns DisplayStep
	 *     comparison returns DisplayStep
	 *     comparison.comparison_1_0 returns DisplayStep
	 *     expr returns DisplayStep
	 *     expr.expr_1_0 returns DisplayStep
	 *     xor_expr returns DisplayStep
	 *     xor_expr.xor_expr_1_0 returns DisplayStep
	 *     and_expr returns DisplayStep
	 *     and_expr.and_expr_1_0 returns DisplayStep
	 *     shift_expr returns DisplayStep
	 *     shift_expr.shift_expr_1_0 returns DisplayStep
	 *     arith_expr returns DisplayStep
	 *     arith_expr.arith_expr_1_0 returns DisplayStep
	 *     term returns DisplayStep
	 *     term.term_1_0 returns DisplayStep
	 *     factor returns DisplayStep
	 *     power returns DisplayStep
	 *     testlist.testlist_1_0 returns DisplayStep
	 *     argument returns DisplayStep
	 *     argument.argument_1_0_0 returns DisplayStep
	 *     argument.argument_1_1_0 returns DisplayStep
	 *
	 * Constraint:
	 *     (id=arith_expr description=arith_expr?)
	 */
	protected void sequence_power(ISerializationContext context, DisplayStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns GetTM
	 *     test.test_0_1_0 returns GetTM
	 *     or_test returns GetTM
	 *     or_test.or_test_1_0 returns GetTM
	 *     and_test returns GetTM
	 *     and_test.and_test_1_0 returns GetTM
	 *     not_test returns GetTM
	 *     comparison returns GetTM
	 *     comparison.comparison_1_0 returns GetTM
	 *     expr returns GetTM
	 *     expr.expr_1_0 returns GetTM
	 *     xor_expr returns GetTM
	 *     xor_expr.xor_expr_1_0 returns GetTM
	 *     and_expr returns GetTM
	 *     and_expr.and_expr_1_0 returns GetTM
	 *     shift_expr returns GetTM
	 *     shift_expr.shift_expr_1_0 returns GetTM
	 *     arith_expr returns GetTM
	 *     arith_expr.arith_expr_1_0 returns GetTM
	 *     term returns GetTM
	 *     term.term_1_0 returns GetTM
	 *     factor returns GetTM
	 *     power returns GetTM
	 *     testlist.testlist_1_0 returns GetTM
	 *     argument returns GetTM
	 *     argument.argument_1_0_0 returns GetTM
	 *     argument.argument_1_1_0 returns GetTM
	 *
	 * Constraint:
	 *     (tm=test args+=arglist* trailer+=trailer*)
	 */
	protected void sequence_power(ISerializationContext context, GetTM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns Goto
	 *     test.test_0_1_0 returns Goto
	 *     or_test returns Goto
	 *     or_test.or_test_1_0 returns Goto
	 *     and_test returns Goto
	 *     and_test.and_test_1_0 returns Goto
	 *     not_test returns Goto
	 *     comparison returns Goto
	 *     comparison.comparison_1_0 returns Goto
	 *     expr returns Goto
	 *     expr.expr_1_0 returns Goto
	 *     xor_expr returns Goto
	 *     xor_expr.xor_expr_1_0 returns Goto
	 *     and_expr returns Goto
	 *     and_expr.and_expr_1_0 returns Goto
	 *     shift_expr returns Goto
	 *     shift_expr.shift_expr_1_0 returns Goto
	 *     arith_expr returns Goto
	 *     arith_expr.arith_expr_1_0 returns Goto
	 *     term returns Goto
	 *     term.term_1_0 returns Goto
	 *     factor returns Goto
	 *     power returns Goto
	 *     testlist.testlist_1_0 returns Goto
	 *     argument returns Goto
	 *     argument.argument_1_0_0 returns Goto
	 *     argument.argument_1_1_0 returns Goto
	 *
	 * Constraint:
	 *     ((target=STRING trailer+=trailer*) | (expr=test trailer+=trailer*))
	 */
	protected void sequence_power(ISerializationContext context, Goto semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns Send
	 *     test.test_0_1_0 returns Send
	 *     or_test returns Send
	 *     or_test.or_test_1_0 returns Send
	 *     and_test returns Send
	 *     and_test.and_test_1_0 returns Send
	 *     not_test returns Send
	 *     comparison returns Send
	 *     comparison.comparison_1_0 returns Send
	 *     expr returns Send
	 *     expr.expr_1_0 returns Send
	 *     xor_expr returns Send
	 *     xor_expr.xor_expr_1_0 returns Send
	 *     and_expr returns Send
	 *     and_expr.and_expr_1_0 returns Send
	 *     shift_expr returns Send
	 *     shift_expr.shift_expr_1_0 returns Send
	 *     arith_expr returns Send
	 *     arith_expr.arith_expr_1_0 returns Send
	 *     term returns Send
	 *     term.term_1_0 returns Send
	 *     factor returns Send
	 *     power returns Send
	 *     testlist.testlist_1_0 returns Send
	 *     argument returns Send
	 *     argument.argument_1_0_0 returns Send
	 *     argument.argument_1_1_0 returns Send
	 *
	 * Constraint:
	 *     (args+=arglist trailer+=trailer*)
	 */
	protected void sequence_power(ISerializationContext context, Send semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns SetLimits
	 *     test.test_0_1_0 returns SetLimits
	 *     or_test returns SetLimits
	 *     or_test.or_test_1_0 returns SetLimits
	 *     and_test returns SetLimits
	 *     and_test.and_test_1_0 returns SetLimits
	 *     not_test returns SetLimits
	 *     comparison returns SetLimits
	 *     comparison.comparison_1_0 returns SetLimits
	 *     expr returns SetLimits
	 *     expr.expr_1_0 returns SetLimits
	 *     xor_expr returns SetLimits
	 *     xor_expr.xor_expr_1_0 returns SetLimits
	 *     and_expr returns SetLimits
	 *     and_expr.and_expr_1_0 returns SetLimits
	 *     shift_expr returns SetLimits
	 *     shift_expr.shift_expr_1_0 returns SetLimits
	 *     arith_expr returns SetLimits
	 *     arith_expr.arith_expr_1_0 returns SetLimits
	 *     term returns SetLimits
	 *     term.term_1_0 returns SetLimits
	 *     factor returns SetLimits
	 *     power returns SetLimits
	 *     testlist.testlist_1_0 returns SetLimits
	 *     argument returns SetLimits
	 *     argument.argument_1_0_0 returns SetLimits
	 *     argument.argument_1_1_0 returns SetLimits
	 *
	 * Constraint:
	 *     ((tm=test args+=arglist* trailer+=trailer*) | (tm=test args+=arglist* trailer+=trailer*))
	 */
	protected void sequence_power(ISerializationContext context, SetLimits semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns ShowTM
	 *     test.test_0_1_0 returns ShowTM
	 *     or_test returns ShowTM
	 *     or_test.or_test_1_0 returns ShowTM
	 *     and_test returns ShowTM
	 *     and_test.and_test_1_0 returns ShowTM
	 *     not_test returns ShowTM
	 *     comparison returns ShowTM
	 *     comparison.comparison_1_0 returns ShowTM
	 *     expr returns ShowTM
	 *     expr.expr_1_0 returns ShowTM
	 *     xor_expr returns ShowTM
	 *     xor_expr.xor_expr_1_0 returns ShowTM
	 *     and_expr returns ShowTM
	 *     and_expr.and_expr_1_0 returns ShowTM
	 *     shift_expr returns ShowTM
	 *     shift_expr.shift_expr_1_0 returns ShowTM
	 *     arith_expr returns ShowTM
	 *     arith_expr.arith_expr_1_0 returns ShowTM
	 *     term returns ShowTM
	 *     term.term_1_0 returns ShowTM
	 *     factor returns ShowTM
	 *     power returns ShowTM
	 *     testlist.testlist_1_0 returns ShowTM
	 *     argument returns ShowTM
	 *     argument.argument_1_0_0 returns ShowTM
	 *     argument.argument_1_1_0 returns ShowTM
	 *
	 * Constraint:
	 *     args+=arglist
	 */
	protected void sequence_power(ISerializationContext context, ShowTM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns Step
	 *     test.test_0_1_0 returns Step
	 *     or_test returns Step
	 *     or_test.or_test_1_0 returns Step
	 *     and_test returns Step
	 *     and_test.and_test_1_0 returns Step
	 *     not_test returns Step
	 *     comparison returns Step
	 *     comparison.comparison_1_0 returns Step
	 *     expr returns Step
	 *     expr.expr_1_0 returns Step
	 *     xor_expr returns Step
	 *     xor_expr.xor_expr_1_0 returns Step
	 *     and_expr returns Step
	 *     and_expr.and_expr_1_0 returns Step
	 *     shift_expr returns Step
	 *     shift_expr.shift_expr_1_0 returns Step
	 *     arith_expr returns Step
	 *     arith_expr.arith_expr_1_0 returns Step
	 *     term returns Step
	 *     term.term_1_0 returns Step
	 *     factor returns Step
	 *     power returns Step
	 *     testlist.testlist_1_0 returns Step
	 *     argument returns Step
	 *     argument.argument_1_0_0 returns Step
	 *     argument.argument_1_1_0 returns Step
	 *
	 * Constraint:
	 *     (id=atom description=arith_expr?)
	 */
	protected void sequence_power(ISerializationContext context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns Verify
	 *     test.test_0_1_0 returns Verify
	 *     or_test returns Verify
	 *     or_test.or_test_1_0 returns Verify
	 *     and_test returns Verify
	 *     and_test.and_test_1_0 returns Verify
	 *     not_test returns Verify
	 *     comparison returns Verify
	 *     comparison.comparison_1_0 returns Verify
	 *     expr returns Verify
	 *     expr.expr_1_0 returns Verify
	 *     xor_expr returns Verify
	 *     xor_expr.xor_expr_1_0 returns Verify
	 *     and_expr returns Verify
	 *     and_expr.and_expr_1_0 returns Verify
	 *     shift_expr returns Verify
	 *     shift_expr.shift_expr_1_0 returns Verify
	 *     arith_expr returns Verify
	 *     arith_expr.arith_expr_1_0 returns Verify
	 *     term returns Verify
	 *     term.term_1_0 returns Verify
	 *     factor returns Verify
	 *     power returns Verify
	 *     testlist.testlist_1_0 returns Verify
	 *     argument returns Verify
	 *     argument.argument_1_0_0 returns Verify
	 *     argument.argument_1_1_0 returns Verify
	 *
	 * Constraint:
	 *     ((args=arglist trailer+=trailer*) | (args=arglist trailer+=trailer*))
	 */
	protected void sequence_power(ISerializationContext context, Verify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns power
	 *     test.test_0_1_0 returns power
	 *     or_test returns power
	 *     or_test.or_test_1_0 returns power
	 *     and_test returns power
	 *     and_test.and_test_1_0 returns power
	 *     not_test returns power
	 *     comparison returns power
	 *     comparison.comparison_1_0 returns power
	 *     expr returns power
	 *     expr.expr_1_0 returns power
	 *     xor_expr returns power
	 *     xor_expr.xor_expr_1_0 returns power
	 *     and_expr returns power
	 *     and_expr.and_expr_1_0 returns power
	 *     shift_expr returns power
	 *     shift_expr.shift_expr_1_0 returns power
	 *     arith_expr returns power
	 *     arith_expr.arith_expr_1_0 returns power
	 *     term returns power
	 *     term.term_1_0 returns power
	 *     factor returns power
	 *     power returns power
	 *     testlist.testlist_1_0 returns power
	 *     argument returns power
	 *     argument.argument_1_0_0 returns power
	 *     argument.argument_1_1_0 returns power
	 *
	 * Constraint:
	 *     (atom=power_power_13_1_0 trailer+=trailer+ factor=factor?)
	 */
	protected void sequence_power(ISerializationContext context, power semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns BuildTC
	 *     simple_stmt returns BuildTC
	 *     simple_stmt.simple_stmt_1_0 returns BuildTC
	 *     small_stmt returns BuildTC
	 *     expr_stmt returns BuildTC
	 *     expr_stmt.expr_stmt_1_0_0 returns BuildTC
	 *     expr_stmt.assignment_stmt_1_1_0 returns BuildTC
	 *     yield_or_testlist returns BuildTC
	 *     testlist returns BuildTC
	 *
	 * Constraint:
	 *     (args+=arglist trailer+=trailer* optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, BuildTC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns ChangeLanguageConfig
	 *     simple_stmt returns ChangeLanguageConfig
	 *     simple_stmt.simple_stmt_1_0 returns ChangeLanguageConfig
	 *     small_stmt returns ChangeLanguageConfig
	 *     expr_stmt returns ChangeLanguageConfig
	 *     expr_stmt.expr_stmt_1_0_0 returns ChangeLanguageConfig
	 *     expr_stmt.assignment_stmt_1_1_0 returns ChangeLanguageConfig
	 *     yield_or_testlist returns ChangeLanguageConfig
	 *     testlist returns ChangeLanguageConfig
	 *
	 * Constraint:
	 *     (statement=Python_Statement args=arglist optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, ChangeLanguageConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns DisplayStep
	 *     simple_stmt returns DisplayStep
	 *     simple_stmt.simple_stmt_1_0 returns DisplayStep
	 *     small_stmt returns DisplayStep
	 *     expr_stmt returns DisplayStep
	 *     expr_stmt.expr_stmt_1_0_0 returns DisplayStep
	 *     expr_stmt.assignment_stmt_1_1_0 returns DisplayStep
	 *     yield_or_testlist returns DisplayStep
	 *     testlist returns DisplayStep
	 *
	 * Constraint:
	 *     (id=arith_expr description=arith_expr? optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, DisplayStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns GetTM
	 *     simple_stmt returns GetTM
	 *     simple_stmt.simple_stmt_1_0 returns GetTM
	 *     small_stmt returns GetTM
	 *     expr_stmt returns GetTM
	 *     expr_stmt.expr_stmt_1_0_0 returns GetTM
	 *     expr_stmt.assignment_stmt_1_1_0 returns GetTM
	 *     yield_or_testlist returns GetTM
	 *     testlist returns GetTM
	 *
	 * Constraint:
	 *     (tm=test args+=arglist* trailer+=trailer* optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, GetTM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns Goto
	 *     simple_stmt returns Goto
	 *     simple_stmt.simple_stmt_1_0 returns Goto
	 *     small_stmt returns Goto
	 *     expr_stmt returns Goto
	 *     expr_stmt.expr_stmt_1_0_0 returns Goto
	 *     expr_stmt.assignment_stmt_1_1_0 returns Goto
	 *     yield_or_testlist returns Goto
	 *     testlist returns Goto
	 *
	 * Constraint:
	 *     (((target=STRING trailer+=trailer*) | (expr=test trailer+=trailer*)) optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, Goto semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns Send
	 *     simple_stmt returns Send
	 *     simple_stmt.simple_stmt_1_0 returns Send
	 *     small_stmt returns Send
	 *     expr_stmt returns Send
	 *     expr_stmt.expr_stmt_1_0_0 returns Send
	 *     expr_stmt.assignment_stmt_1_1_0 returns Send
	 *     yield_or_testlist returns Send
	 *     testlist returns Send
	 *
	 * Constraint:
	 *     (args+=arglist trailer+=trailer* optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, Send semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns SetLimits
	 *     simple_stmt returns SetLimits
	 *     simple_stmt.simple_stmt_1_0 returns SetLimits
	 *     small_stmt returns SetLimits
	 *     expr_stmt returns SetLimits
	 *     expr_stmt.expr_stmt_1_0_0 returns SetLimits
	 *     expr_stmt.assignment_stmt_1_1_0 returns SetLimits
	 *     yield_or_testlist returns SetLimits
	 *     testlist returns SetLimits
	 *
	 * Constraint:
	 *     (((tm=test args+=arglist* trailer+=trailer*) | (tm=test args+=arglist* trailer+=trailer*)) optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, SetLimits semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns ShowTM
	 *     simple_stmt returns ShowTM
	 *     simple_stmt.simple_stmt_1_0 returns ShowTM
	 *     small_stmt returns ShowTM
	 *     expr_stmt returns ShowTM
	 *     expr_stmt.expr_stmt_1_0_0 returns ShowTM
	 *     expr_stmt.assignment_stmt_1_1_0 returns ShowTM
	 *     yield_or_testlist returns ShowTM
	 *     testlist returns ShowTM
	 *
	 * Constraint:
	 *     (args+=arglist optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, ShowTM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns Step
	 *     simple_stmt returns Step
	 *     simple_stmt.simple_stmt_1_0 returns Step
	 *     small_stmt returns Step
	 *     expr_stmt returns Step
	 *     expr_stmt.expr_stmt_1_0_0 returns Step
	 *     expr_stmt.assignment_stmt_1_1_0 returns Step
	 *     yield_or_testlist returns Step
	 *     testlist returns Step
	 *
	 * Constraint:
	 *     (id=atom description=arith_expr? optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns Verify
	 *     simple_stmt returns Verify
	 *     simple_stmt.simple_stmt_1_0 returns Verify
	 *     small_stmt returns Verify
	 *     expr_stmt returns Verify
	 *     expr_stmt.expr_stmt_1_0_0 returns Verify
	 *     expr_stmt.assignment_stmt_1_1_0 returns Verify
	 *     yield_or_testlist returns Verify
	 *     testlist returns Verify
	 *
	 * Constraint:
	 *     (((args=arglist trailer+=trailer*) | (args=arglist trailer+=trailer*)) optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, Verify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns power
	 *     simple_stmt returns power
	 *     simple_stmt.simple_stmt_1_0 returns power
	 *     small_stmt returns power
	 *     expr_stmt returns power
	 *     expr_stmt.expr_stmt_1_0_0 returns power
	 *     expr_stmt.assignment_stmt_1_1_0 returns power
	 *     yield_or_testlist returns power
	 *     testlist returns power
	 *
	 * Constraint:
	 *     (atom=power_power_13_1_0 trailer+=trailer+ factor=factor? optionalComma?=','?)
	 */
	protected void sequence_power_testlist(ISerializationContext context, power semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns raise_stmt
	 *     simple_stmt returns raise_stmt
	 *     simple_stmt.simple_stmt_1_0 returns raise_stmt
	 *     small_stmt returns raise_stmt
	 *     flow_stmt returns raise_stmt
	 *     raise_stmt returns raise_stmt
	 *
	 * Constraint:
	 *     (tests+=test (tests+=test tests+=test?)?)?
	 */
	protected void sequence_raise_stmt(ISerializationContext context, raise_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns return_stmt
	 *     simple_stmt returns return_stmt
	 *     simple_stmt.simple_stmt_1_0 returns return_stmt
	 *     small_stmt returns return_stmt
	 *     flow_stmt returns return_stmt
	 *     return_stmt returns return_stmt
	 *
	 * Constraint:
	 *     testlist=testlist?
	 */
	protected void sequence_return_stmt(ISerializationContext context, return_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns shift_expr
	 *     test.test_0_1_0 returns shift_expr
	 *     or_test returns shift_expr
	 *     or_test.or_test_1_0 returns shift_expr
	 *     and_test returns shift_expr
	 *     and_test.and_test_1_0 returns shift_expr
	 *     not_test returns shift_expr
	 *     comparison returns shift_expr
	 *     comparison.comparison_1_0 returns shift_expr
	 *     expr returns shift_expr
	 *     expr.expr_1_0 returns shift_expr
	 *     xor_expr returns shift_expr
	 *     xor_expr.xor_expr_1_0 returns shift_expr
	 *     and_expr returns shift_expr
	 *     and_expr.and_expr_1_0 returns shift_expr
	 *     shift_expr returns shift_expr
	 *     shift_expr.shift_expr_1_0 returns shift_expr
	 *     testlist.testlist_1_0 returns shift_expr
	 *     argument returns shift_expr
	 *     argument.argument_1_0_0 returns shift_expr
	 *     argument.argument_1_1_0 returns shift_expr
	 *
	 * Constraint:
	 *     (left=shift_expr_shift_expr_1_0 (sign='<<' | sign='>>') right=arith_expr)
	 */
	protected void sequence_shift_expr(ISerializationContext context, shift_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns shift_expr
	 *     simple_stmt returns shift_expr
	 *     simple_stmt.simple_stmt_1_0 returns shift_expr
	 *     small_stmt returns shift_expr
	 *     expr_stmt returns shift_expr
	 *     expr_stmt.expr_stmt_1_0_0 returns shift_expr
	 *     expr_stmt.assignment_stmt_1_1_0 returns shift_expr
	 *     yield_or_testlist returns shift_expr
	 *     testlist returns shift_expr
	 *
	 * Constraint:
	 *     (left=shift_expr_shift_expr_1_0 (sign='<<' | sign='>>') right=arith_expr optionalComma?=','?)
	 */
	protected void sequence_shift_expr_testlist(ISerializationContext context, shift_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns simple_stmt
	 *     simple_stmt returns simple_stmt
	 *
	 * Constraint:
	 *     (stmt+=simple_stmt_simple_stmt_1_0 stmt+=small_stmt+ additionalComma?=','?)
	 */
	protected void sequence_simple_stmt(ISerializationContext context, simple_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     python_input returns single_input
	 *     single_input returns single_input
	 *
	 * Constraint:
	 *     (stmt=simple_stmt | stmt=compound_stmt)
	 */
	protected void sequence_single_input(ISerializationContext context, single_input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sliceop returns sliceop
	 *
	 * Constraint:
	 *     test=test?
	 */
	protected void sequence_sliceop(ISerializationContext context, sliceop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     subscript returns subscript
	 *
	 * Constraint:
	 *     (subscript1=test? (symbol=':' subscript2=test? sliceop=sliceop?)?)
	 */
	protected void sequence_subscript(ISerializationContext context, subscript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     subscriptlist returns subscriptlist
	 *
	 * Constraint:
	 *     (subscript+=subscript subscript+=subscript* optionalComma?=','?)
	 */
	protected void sequence_subscriptlist(ISerializationContext context, subscriptlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     suite returns suite
	 *
	 * Constraint:
	 *     stmts+=stmt+
	 */
	protected void sequence_suite(ISerializationContext context, suite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns term
	 *     test.test_0_1_0 returns term
	 *     or_test returns term
	 *     or_test.or_test_1_0 returns term
	 *     and_test returns term
	 *     and_test.and_test_1_0 returns term
	 *     not_test returns term
	 *     comparison returns term
	 *     comparison.comparison_1_0 returns term
	 *     expr returns term
	 *     expr.expr_1_0 returns term
	 *     xor_expr returns term
	 *     xor_expr.xor_expr_1_0 returns term
	 *     and_expr returns term
	 *     and_expr.and_expr_1_0 returns term
	 *     shift_expr returns term
	 *     shift_expr.shift_expr_1_0 returns term
	 *     arith_expr returns term
	 *     arith_expr.arith_expr_1_0 returns term
	 *     term returns term
	 *     term.term_1_0 returns term
	 *     testlist.testlist_1_0 returns term
	 *     argument returns term
	 *     argument.argument_1_0_0 returns term
	 *     argument.argument_1_1_0 returns term
	 *
	 * Constraint:
	 *     (left=term_term_1_0 (sign='*' | sign='/' | sign='%' | sign='//' | sign='**') right=factor)
	 */
	protected void sequence_term(ISerializationContext context, term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns term
	 *     simple_stmt returns term
	 *     simple_stmt.simple_stmt_1_0 returns term
	 *     small_stmt returns term
	 *     expr_stmt returns term
	 *     expr_stmt.expr_stmt_1_0_0 returns term
	 *     expr_stmt.assignment_stmt_1_1_0 returns term
	 *     yield_or_testlist returns term
	 *     testlist returns term
	 *
	 * Constraint:
	 *     (left=term_term_1_0 (sign='*' | sign='/' | sign='%' | sign='//' | sign='**') right=factor optionalComma?=','?)
	 */
	protected void sequence_term_testlist(ISerializationContext context, term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns test
	 *     testlist.testlist_1_0 returns test
	 *     argument returns test
	 *     argument.argument_1_0_0 returns test
	 *     argument.argument_1_1_0 returns test
	 *
	 * Constraint:
	 *     (left=test_test_0_1_0 if_test=or_test if_else_test=test)
	 */
	protected void sequence_test(ISerializationContext context, test semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.TEST__IF_TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.TEST__IF_TEST));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.TEST__IF_ELSE_TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.TEST__IF_ELSE_TEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestAccess().getTestLeftAction_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTestAccess().getIf_testOr_testParserRuleCall_0_1_2_0(), semanticObject.getIf_test());
		feeder.accept(grammarAccess.getTestAccess().getIf_else_testTestParserRuleCall_0_1_4_0(), semanticObject.getIf_else_test());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns test
	 *     simple_stmt returns test
	 *     simple_stmt.simple_stmt_1_0 returns test
	 *     small_stmt returns test
	 *     expr_stmt returns test
	 *     expr_stmt.expr_stmt_1_0_0 returns test
	 *     expr_stmt.assignment_stmt_1_1_0 returns test
	 *     yield_or_testlist returns test
	 *     testlist returns test
	 *
	 * Constraint:
	 *     (left=test_test_0_1_0 if_test=or_test if_else_test=test optionalComma?=','?)
	 */
	protected void sequence_test_testlist(ISerializationContext context, test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     testlist1 returns testlist1
	 *
	 * Constraint:
	 *     (tests+=test tests+=test*)
	 */
	protected void sequence_testlist1(ISerializationContext context, testlist1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     yield_or_testlist_comp returns testlist_comp
	 *     testlist_comp returns testlist_comp
	 *
	 * Constraint:
	 *     (test=test (comp_for=comp_for | (additionalTests+=test* optionalComma?=','?))?)
	 */
	protected void sequence_testlist_comp(ISerializationContext context, testlist_comp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     testlist_safe returns testlist_safe
	 *
	 * Constraint:
	 *     (old_test+=test (old_test+=test+ optionalComa?=','?)?)
	 */
	protected void sequence_testlist_safe(ISerializationContext context, testlist_safe semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns testlist
	 *     simple_stmt returns testlist
	 *     simple_stmt.simple_stmt_1_0 returns testlist
	 *     small_stmt returns testlist
	 *     expr_stmt returns testlist
	 *     expr_stmt.expr_stmt_1_0_0 returns testlist
	 *     expr_stmt.assignment_stmt_1_1_0 returns testlist
	 *     yield_or_testlist returns testlist
	 *     testlist returns testlist
	 *
	 * Constraint:
	 *     (tests+=testlist_testlist_1_0 tests+=test optionalComma?=','?)
	 */
	protected void sequence_testlist(ISerializationContext context, testlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     testlist.testlist_1_0 returns testlist
	 *
	 * Constraint:
	 *     (tests+=testlist_testlist_1_0 tests+=test)
	 */
	protected void sequence_testlist_testlist_1_0(ISerializationContext context, testlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns xor_expr
	 *     simple_stmt returns xor_expr
	 *     simple_stmt.simple_stmt_1_0 returns xor_expr
	 *     small_stmt returns xor_expr
	 *     expr_stmt returns xor_expr
	 *     expr_stmt.expr_stmt_1_0_0 returns xor_expr
	 *     expr_stmt.assignment_stmt_1_1_0 returns xor_expr
	 *     yield_or_testlist returns xor_expr
	 *     testlist returns xor_expr
	 *
	 * Constraint:
	 *     (left=xor_expr_xor_expr_1_0 sign='^' right=and_expr optionalComma?=','?)
	 */
	protected void sequence_testlist_xor_expr(ISerializationContext context, xor_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     trailer returns trailer
	 *
	 * Constraint:
	 *     ((roundBracket?='(' arglist=arglist?) | (squareBracket?='[' subscriptlist=subscriptlist) | dotName=NAME)
	 */
	protected void sequence_trailer(ISerializationContext context, trailer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns try_stmt
	 *     compound_stmt returns try_stmt
	 *     try_stmt returns try_stmt
	 *
	 * Constraint:
	 *     (suite=suite ((except_clause+=except_clause+ else=suite? finally=suite?) | finally=suite))
	 */
	protected void sequence_try_stmt(ISerializationContext context, try_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     varargslist_element returns varargslist_element
	 *
	 * Constraint:
	 *     (fpdef=fpdef test=test?)
	 */
	protected void sequence_varargslist_element(ISerializationContext context, varargslist_element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     varargslist returns varargslist
	 *
	 * Constraint:
	 *     (
	 *         (varargs1+=varargslist_element* ((dot1Name=NAME dot2Name=NAME?) | dot2Name=NAME)) | 
	 *         (vararg2=varargslist_element varargs3+=varargslist_element* additionalComma?=','?)
	 *     )
	 */
	protected void sequence_varargslist(ISerializationContext context, varargslist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns while_stmt
	 *     compound_stmt returns while_stmt
	 *     while_stmt returns while_stmt
	 *
	 * Constraint:
	 *     (test=test suite=suite else=suite?)
	 */
	protected void sequence_while_stmt(ISerializationContext context, while_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     with_item returns with_item
	 *
	 * Constraint:
	 *     (test=test expr=expr?)
	 */
	protected void sequence_with_item(ISerializationContext context, with_item semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns with_stmt
	 *     compound_stmt returns with_stmt
	 *     with_stmt returns with_stmt
	 *
	 * Constraint:
	 *     (with_item+=with_item with_item+=with_item* suite=suite)
	 */
	protected void sequence_with_stmt(ISerializationContext context, with_stmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     test returns xor_expr
	 *     test.test_0_1_0 returns xor_expr
	 *     or_test returns xor_expr
	 *     or_test.or_test_1_0 returns xor_expr
	 *     and_test returns xor_expr
	 *     and_test.and_test_1_0 returns xor_expr
	 *     not_test returns xor_expr
	 *     comparison returns xor_expr
	 *     comparison.comparison_1_0 returns xor_expr
	 *     expr returns xor_expr
	 *     expr.expr_1_0 returns xor_expr
	 *     xor_expr returns xor_expr
	 *     xor_expr.xor_expr_1_0 returns xor_expr
	 *     testlist.testlist_1_0 returns xor_expr
	 *     argument returns xor_expr
	 *     argument.argument_1_0_0 returns xor_expr
	 *     argument.argument_1_1_0 returns xor_expr
	 *
	 * Constraint:
	 *     (left=xor_expr_xor_expr_1_0 sign='^' right=and_expr)
	 */
	protected void sequence_xor_expr(ISerializationContext context, xor_expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.OR_TEST__SIGN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.OR_TEST__SIGN));
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.EXPR_STMT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXor_exprAccess().getXor_exprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXor_exprAccess().getSignCircumflexAccentKeyword_1_1_0(), semanticObject.getSign());
		feeder.accept(grammarAccess.getXor_exprAccess().getRightAnd_exprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     yield_or_testlist returns yield_expr
	 *     yield_or_testlist_comp returns yield_expr
	 *     yield_expr returns yield_expr
	 *
	 * Constraint:
	 *     testlist=testlist?
	 */
	protected void sequence_yield_expr(ISerializationContext context, yield_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmt returns yield_stmt
	 *     simple_stmt returns yield_stmt
	 *     simple_stmt.simple_stmt_1_0 returns yield_stmt
	 *     small_stmt returns yield_stmt
	 *     flow_stmt returns yield_stmt
	 *     yield_stmt returns yield_stmt
	 *
	 * Constraint:
	 *     yield_expr=yield_expr
	 */
	protected void sequence_yield_stmt(ISerializationContext context, yield_stmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellPackage.Literals.YIELD_STMT__YIELD_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellPackage.Literals.YIELD_STMT__YIELD_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYield_stmtAccess().getYield_exprYield_exprParserRuleCall_0(), semanticObject.getYield_expr());
		feeder.finish();
	}
	
	
}
